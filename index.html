<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dynamic Style Containers</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background-color: #f0f0f0;
    }
    .button-container {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }
    .button-container button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      transition: 0.3s;
    }
    .button-container button:hover {
      opacity: 0.9;
    }
    .tool-container {
      display: none; /* مخفي افتراضياً */
      padding: 20px;
      margin: 10px 0;
      border-radius: 5px;
      width: 90%;
      max-width: 900px;
      text-align: center;
      animation: fadeIn 0.4s ease;
    }
    .reset-btn {
      background-color: #ff4d4d;
      color: white;
      margin-top: 15px;
      padding: 8px 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to   { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>
<body>
  <!-- الأزرار الرئيسية -->
  <div class="button-container" id="main-button-container">
    <button onclick="addContainer(1)">زر 1</button>
    <button onclick="addContainer(2)">زر 2</button>
    <button onclick="addContainer(3)">زر 3</button>
  </div>

  <!-- الكونتينرات -->
  <div id="container-1" class="tool-container">
    <h2>كونتينر 1</h2>
    <p>هذا خاص بالزر 1</p>
    <button id="reset-btn-1" class="reset-btn" onclick="resetPage()">الرجوع</button>
  </div>

  <div id="container-2" class="tool-container">
    <h2>كونتينر 2</h2>
    <p>هذا خاص بالزر 2</p>
    <button id="reset-btn-2" class="reset-btn" onclick="resetPage()">الرجوع</button>
  </div>

  <div id="container-3" class="tool-container">
    <h2>كونتينر 3</h2>
    <p>هذا خاص بالزر 3</p>
    <button id="reset-btn-3" class="reset-btn" onclick="resetPage()">الرجوع</button>
  </div>

  <script>
    function addContainer(buttonId) {
      // إزالة أي style قديم
      const existingStyle = document.querySelector("style[data-dynamic]");
      if (existingStyle) existingStyle.remove();

      // إنشاء style جديد
      const styleTag = document.createElement("style");
      styleTag.setAttribute("data-dynamic", "true");

    let containerStyle = "";
    switch (buttonId) {
        // For tool #1
        case 1:
        containerStyle = `
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Arial, sans-serif;
        background: linear-gradient(135deg, #f5f7fa 0%, #e4e9f0 100%);
        min-height: 100vh;
        min-width: 100vw;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        overflow-x: hidden;
      }

      body.dark-mode {
        background: linear-gradient(135deg, #18191a 0%, #232526 100%);
        color: #f0f0f0;
      }

      .main-container {
        max-width: 98vw;
        width: 100%;
        margin: 2vw auto;
        padding: 30px 20px;
        background: #f8f8f8;
        border-radius: 24px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.1);
        position: relative;
      }
      body.dark-mode .main-container {
        background: #18191a;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      }

      .container {
        max-width: 500px;
        width: 100%;
        background: #ffffff;
        padding: 30px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        z-index: 1;
        margin: 0 auto;
        transform: translateZ(10px);
      }

      .dark-mode .container {
        background: #232526;
        color: #f0f0f0;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        color: white;
        padding: 15px;
        border-radius: 12px;
        margin-bottom: 25px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .dark-mode .header {
        background: linear-gradient(90deg, #ff6200 80%, #232526 100%);
        color: #fff;
      }

      h2 {
        font-size: 24px;
        text-align: left;
        margin: 0;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }

      .reset-form-btn {
        background: linear-gradient(90deg, #ff1a1a, #ff4d4d);
        width: auto;
        padding: 8px 20px;
        font-size: 14px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: none;
        color: white;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      }

      .reset-form-btn:hover {
        background: linear-gradient(90deg, #e60000, #ff3333);
        transform: translateY(-2px) translateZ(5px);
        box-shadow: 0 5px 15px rgba(255, 26, 26, 0.4);
      }

      .dark-mode .reset-form-btn {
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        color: #fff;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
      }

      .dark-mode .reset-form-btn:hover {
        background: linear-gradient(90deg, #e65600, #ff8c00);
        color: #fff;
      }

      label {
        font-weight: 600;
        display: block;
        text-align: left;
        margin-bottom: 8px;
        color: #222;
      }

      .dark-mode label,
      .dark-mode .required-message {
        color: #ffd580;
      }

      input {
        width: 100%;
        padding: 12px;
        margin-bottom: 15px;
        border: 2px solid #ccc;
        border-radius: 10px;
        font-size: 16px;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        background: #f9f9f9;
      }

      .dark-mode input,
      .dark-mode select {
        background: #232526;
        color: #f0f0f0;
        border: 2px solid #666;
      }

      input:focus {
        border-color: #ff6200;
        outline: none;
        box-shadow: 0 0 8px rgba(255, 98, 0, 0.3);
      }

      .dark-mode input:focus,
      .dark-mode select:focus {
        border-color: #ff9a00;
        box-shadow: 0 0 8px #ff9a00;
      }

      input.invalid {
        border-color: #ff1a1a;
        animation: shake 0.3s ease-in-out;
      }

      .dark-mode input.invalid {
        border-color: #ff4d4d;
      }

      @keyframes shake {
        0% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        50% {
          transform: translateX(5px);
        }
        75% {
          transform: translateX(-5px);
        }
        100% {
          transform: translateX(0);
        }
      }

      button {
        width: 100%;
        padding: 12px;
        font-size: 16px;
        font-weight: 600;
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        color: white;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: none;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      button:hover {
        background: linear-gradient(90deg, #e65600, #ff8c00);
        transform: translateY(-2px) translateZ(5px);
        box-shadow: 0 8px 20px rgba(255, 98, 0, 0.4);
      }

      .dark-mode button,
      .dark-mode .reset-form-btn {
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        color: #fff;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
      }

      .dark-mode button:hover,
      .dark-mode .reset-form-btn:hover {
        background: linear-gradient(90deg, #e65600, #ff8c00);
        color: #fff;
      }

      button:disabled {
        background: #b0b0b0;
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
        box-shadow: none;
      }

      .dark-mode button:disabled {
        background: #444;
        color: #aaa;
      }

      #result {
        opacity: 0;
        transition: all 0.5s ease-in-out;
        margin-top: 20px;
        padding: 15px;
        border-radius: 12px;
        text-align: center;
        font-size: 20px;
        font-weight: 700;
        color: white;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        transform: translateZ(10px);
        position: relative;
      }

      .dark-mode #result {
        color: #fff;
        background: #333;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
      }

      #result.show {
        opacity: 1;
        transform: translateZ(15px) scale(1.02);
      }

      #compensation {
        position: fixed;
        left: -400px;
        top: 80px;
        width: 280px;
        background: linear-gradient(135deg, #ff3333, #ff6666);
        color: white;
        font-size: 16px;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        transition: left 0.5s ease-in-out;
        z-index: 2;
        text-align: left;
        transform: translateZ(10px);
      }

      .dark-mode #compensation {
        background: linear-gradient(135deg, #b34700, #ff6200);
        color: #fff;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.7);
      }

      #compensation.show {
        left: 20px;
      }

      #compensation h3 {
        font-size: 22px;
        margin-bottom: 15px;
        text-align: center;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }

      #compensation ul {
        padding-left: 20px;
        margin: 0;
      }

      #compensation ul li {
        margin-bottom: 8px;
        list-style: square;
      }

      #copyCompensationBtn {
        background: linear-gradient(90deg, #ffd700, #ffea00);
        color: #222;
        font-size: 16px;
        font-weight: 600;
        padding: 10px;
        margin-top: 15px;
        border-radius: 10px;
        cursor: pointer;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        animation: pulse 1.5s infinite;
        width: 100%;
        border: none;
        display: none;
      }

      .dark-mode #copyCompensationBtn {
        background: linear-gradient(90deg, #ffd700, #ffea00);
        color: #222;
      }

      @keyframes pulse {
        0% {
          transform: scale(1) translateZ(0);
        }
        50% {
          transform: scale(1.05) translateZ(5px);
        }
        100% {
          transform: scale(1) translateZ(0);
        }
      }

      .right-reminder {
        position: fixed;
        top: 100px;
        right: -400px;
        width: 280px;
        background: #fff5e6;
        color: #222;
        font-size: 16px;
        font-weight: 500;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        transition: right 0.5s ease-in-out;
        text-align: center;
        z-index: 3;
        transform: translateZ(10px);
      }

      .dark-mode .right-reminder {
        background: #232526;
        color: #ffd580;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.7);
      }

      .right-reminder.show {
        right: 20px;
      }

      .right-reminder .emoji {
        font-size: 50px;
        margin-bottom: 10px;
      }

      .right-reminder .paper {
        background-color: #fff;
        padding: 10px;
        margin-top: 10px;
        border-radius: 8px;
        border: 2px dashed #ff6200;
        font-weight: 600;
        font-size: 14px;
      }

      .third-reminder {
        position: fixed;
        top: 400px;
        left: -400px;
        width: 220px;
        background: linear-gradient(135deg, #ffd700, #ffea00);
        color: #222;
        font-size: 14px;
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        transition: left 0.5s ease-in-out;
        z-index: 1000;
        text-align: center;
        animation: shake 0.5s ease-in-out infinite;
        transform: translateZ(10px);
      }

      .dark-mode .third-reminder {
        background: linear-gradient(135deg, #b34700, #ffd700);
        color: #232526;
      }

      .third-reminder.show {
        left: 20px;
      }

      .third-reminder .emoji {
        font-size: 30px;
        margin-bottom: 5px;
      }

      .third-reminder h3 {
        font-size: 16px;
        margin-bottom: 5px;
      }

      .third-reminder p {
        margin: 5px 0;
      }

      #timeLeft {
        display: inline-block;
        font-size: 18px;
        font-weight: bold;
        color: #ff3333;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        background-color: #ffffff;
        padding: 5px 10px;
        border-radius: 5px;
        margin: 5px;
        animation: blink 1s infinite;
      }

      @keyframes blink {
        0% {
          background-color: #ffffff;
        }
        50% {
          background-color: #ff9999;
        }
        100% {
          background-color: #ffffff;
        }
      }

      @keyframes shake {
        0% {
          transform: translateX(0) translateZ(10px);
        }
        25% {
          transform: translateX(-5px) translateZ(10px);
        }
        50% {
          transform: translateX(5px) translateZ(10px);
        }
        75% {
          transform: translateX(-5px) translateZ(10px);
        }
        100% {
          transform: translateX(0) translateZ(10px);
        }
      }

      .time-calculator {
        position: fixed;
        top: 300px;
        right: 20px;
        width: 280px;
        background: linear-gradient(135deg, #ffe6cc, #fff5e6);
        color: #222;
        font-size: 16px;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        text-align: center;
        z-index: 3;
        transform: translateZ(10px);
      }

      .dark-mode .time-calculator {
        background: linear-gradient(135deg, #232526, #333);
        color: #fff;
      }

      .time-calculator h3 {
        font-size: 18px;
        margin-bottom: 15px;
        color: #ff6200;
      }

      .time-calculator input {
        margin-bottom: 10px;
        font-size: 14px;
      }

      .time-calculator button {
        font-size: 14px;
        padding: 10px;
      }

      .time-calculator #timeCalcResult {
        margin-top: 10px;
        font-size: 14px;
        font-weight: 600;
        color: #222;
        background-color: #fff;
        padding: 8px;
        border-radius: 8px;
        border: 2px dashed #ff6200;
      }

      .time-calculator #timeCalcResetCountdown {
        margin-top: 10px;
        color: #666;
        font-size: 12px;
        font-style: italic;
      }

      .time-calc-reminder {
        position: fixed;
        top: 460px;
        right: -400px;
        width: 280px;
        background: linear-gradient(135deg, #ffcc99, #ffdb80);
        color: #222;
        font-size: 16px;
        padding: 15px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        transition: right 0.5s ease-in-out;
        text-align: center;
        z-index: 3;
        transform: translateZ(10px);
      }

      .dark-mode .time-calc-reminder {
        background: linear-gradient(135deg, #b34700, #ffcc99);
        color: #fff;
      }

      .time-calc-reminder.show {
        right: 20px;
      }

      .time-calc-reminder p {
        font-weight: 600;
      }

      .time-calc-service-message {
        position: fixed;
        top: 510px;
        right: -400px;
        width: 280px;
        background: linear-gradient(135deg, #ff9999, #ffcccc);
        color: #222;
        font-size: 14px;
        padding: 15px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        transition: right 0.5s ease-in-out;
        text-align: center;
        z-index: 3;
        transform: translateZ(10px);
      }

      .dark-mode .time-calc-service-message {
        background: linear-gradient(135deg, #333, #ffb366);
        color: #fff;
      }

      .time-calc-service-message.show {
        right: 20px;
      }

      .time-calc-service-message p {
        font-weight: 600;
      }

      .time-calc-service-message .highlight {
        font-weight: bold;
        color: #ff3333;
      }

      .dark-mode .time-calc-service-message .highlight {
        color: #ffd700;
      }

      .failed-trials {
        position: fixed;
        left: -400px;
        top: 30%;
        width: 280px;
        background: linear-gradient(135deg, #ff9999, #ffcccc);
        color: #222;
        font-size: 16px;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        transition: left 0.5s ease-in-out;
        z-index: 2;
        text-align: left;
        transform: translateZ(10px);
      }

      .dark-mode .failed-trials {
        background: linear-gradient(135deg, #b34700, #ff9999);
        color: #fff;
      }

      .failed-trials.show {
        left: 20px;
      }

      .failed-trials h3 {
        font-size: 22px;
        margin-bottom: 15px;
        text-align: center;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }

      .failed-trials ul {
        padding-left: 20px;
        margin: 0;
      }

      .failed-trials ul li {
        margin-bottom: 8px;
        list-style: square;
      }

      .refund-sla-panel {
        position: fixed;
        bottom: 26%;
        left: -400px;
        width: 280px;
        background: linear-gradient(135deg, #fff5e6, #ffe6cc);
        color: #222;
        font-size: 16px;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        text-align: center;
        z-index: 3;
        transform: translateZ(10px);
        transition: left 0.5s ease-in-out;
      }

      .dark-mode .refund-sla-panel {
        background: linear-gradient(135deg, #232526, #333);
        color: #ffd580;
      }

      .refund-sla-panel.show {
        left: 20px;
      }

      .refund-sla-panel h3 {
        font-size: 18px;
        margin-bottom: 15px;
        color: #ff6200;
      }

      .refund-sla-panel select {
        width: 100%;
        /*padding: 10px;*/
        font-size: 14px;
        border: 2px solid #ccc;
        border-radius: 10px;
        background: #f9f9f9;
        color: #222;
        cursor: pointer;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        pointer-events: auto;
      }

      .dark-mode .refund-sla-panel select {
        background: #2d2f31;
        color: #fff;
        border: 2px solid #444;
      }

      .refund-sla-panel select:focus {
        border-color: #ff6200;
        outline: none;
        box-shadow: 0 0 8px rgba(255, 98, 0, 0.3);
      }

      .refund-sla-details {
        position: absolute;
        top: 100px;
        left: 0;
        right: 0;
        width: 240px;
        margin: 0 auto;
        background: #fff;
        color: #222;
        font-size: 14px;
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        transform: translateY(-20px);
        opacity: 0;
        transition: all 0.5s ease-in-out;
        z-index: 4;
        border: 2px dashed #ff6200;
        direction: rtl;
        text-align: right;
      }

      .dark-mode .refund-sla-details {
        background: #232526;
        color: #fff;
        border-color: #ff6200;
      }

      .refund-sla-details.show {
        transform: translateY(0);
        opacity: 1;
      }

      .refund-sla-details p {
        margin: 8px 0;
        font-weight: 500;
      }

      .refund-sla-details .highlight {
        font-weight: bold;
        color: #ff6200;
      }

      .marquee {
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        color: white;
        font-size: 16px;
        padding: 10px 0;
        overflow: hidden;
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        z-index: 999;
        box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.2);
      }

      .dark-mode .marquee {
        background: linear-gradient(90deg, #ff6200, #232526);
        color: #ffd580;
      }

      .marquee-text {
        display: inline-block;
        white-space: nowrap;
        padding-left: 100%;
        animation: scroll 80s linear infinite;
      }

      @keyframes scroll {
        0% {
          transform: translateX(0);
        }
        100% {
          transform: translateX(-100%);
        }
      }

      #orderTimers {
        margin-top: 30px;
      }

      .service-selection {
        display: flex;
        justify-content: space-between;
        margin: 20px 0 25px;
        gap: 10px;
      }

      .service-option {
        flex: 1;
        text-align: center;
        position: relative;
        cursor: pointer;
      }

      .service-option input[type="checkbox"] {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
      }

      .service-option label {
        display: block;
        background-color: #f0f0f0;
        border: 2px solid #ccc;
        border-radius: 10px;
        padding: 12px 8px;
        font-size: 14px;
        font-weight: 600;
        color: #444;
        transition: all 0.3s ease;
        cursor: pointer;
        text-align: center;
      }

      .dark-mode .service-option label {
        background-color: #232526;
        border: 2px solid #666;
        color: #ffd580;
      }

      .service-option:nth-child(1) label {
        color: #ff6200;
      }

      .service-option:nth-child(2) label {
        color: #0066cc;
      }

      .service-option:nth-child(3) label {
        color: #990099;
      }

      .service-option input[type="checkbox"]:checked + label {
        background-color: #fff;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        transform: translateY(-3px) translateZ(5px);
        border-color: currentColor;
      }

      .dark-mode .service-option input[type="checkbox"]:checked + label {
        background-color: #333;
        border-color: #ff6200;
        color: #ff6200;
      }

      .service-option:nth-child(1) input[type="checkbox"]:checked + label {
        background-color: #fff5e6;
      }

      .service-option:nth-child(2) input[type="checkbox"]:checked + label {
        background-color: #e6f0ff;
      }

      .service-option:nth-child(3) input[type="checkbox"]:checked + label {
        background-color: #f5e6ff;
      }

      #resetCountdown {
        margin-top: 15px;
        color: #666;
        font-size: 14px;
        font-style: italic;
        text-align: center;
      }

      .required-message {
        color: #ff3333;
        font-size: 13px;
        text-align: center;
        margin-top: -10px;
        margin-bottom: 10px;
        font-style: italic;
      }

      .dark-mode .required-message {
        color: #ffd580;
      }

      .order-timer-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background-color: #f0f0f0;
        padding: 12px 15px;
        border-radius: 10px;
        margin-bottom: 10px;
        transition: all 0.3s ease;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
      }

      .dark-mode .order-timer-item {
        background: #232526;
        color: #fff;
      }

      .order-timer-item.completed {
        background-color: #e6ffcc;
        color: #006600;
        text-decoration: line-through;
      }

      .dark-mode .order-timer-item.completed {
        background: #2d2f31;
        color: #00cc00;
      }

      .order-timer-checkbox {
        margin-right: 10px;
        transform: scale(1.5);
        cursor: pointer;
      }

      .dark-mode .order-timer-checkbox {
        accent-color: #ff9a00;
      }

      .order-timer-content {
        flex-grow: 1;
        text-align: left;
        margin-left: 8px;
        display: flex;
        align-items: center;
      }

      .timer-display {
        margin-left: 10px;
        font-weight: 600;
      }

      .timer-progress {
        width: 50px;
        height: 10px;
        background-color: #ccc;
        border-radius: 5px;
        overflow: hidden;
        margin-left: 10px;
      }

      .dark-mode .timer-progress {
        background-color: #444;
      }

      .timer-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        transition: width 1s linear;
      }

      .dark-mode .timer-progress-bar {
        background: linear-gradient(90deg, #ff6200, #ff9a00);
      }

      .timer-controls {
        display: flex;
        align-items: center;
      }

      .delete-timer {
        background: none;
        border: none;
        color: #ff3333;
        cursor: pointer;
        font-size: 18px;
        padding: 0 8px;
        margin-left: 8px;
        width: auto;
      }

      .dark-mode .delete-timer {
        color: #ff4d4d;
      }

      .order-type-selection {
        display: flex;
        gap: 10px;
        margin-top: 8px;
      }
      .order-type-selection input[type="radio"] {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
      }
      .order-type-option {
        flex: 1;
        text-align: center;
        background-color: #f0f0f0;
        border: 2px solid #ccc;
        border-radius: 10px;
        padding: 12px 8px;
        font-size: 14px;
        font-weight: 600;
        color: #444;
        transition: all 0.3s ease;
        cursor: pointer;
        user-select: none;
      }
      .dark-mode .order-type-option {
        background-color: #232526;
        border: 2px solid #666;
        color: #ffd580;
      }
      .order-type-selection input[type="radio"]:checked + .order-type-option {
        background-color: #fff5e6;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        transform: translateY(-3px) translateZ(5px);
        border-color: #ff6200;
        color: #ff6200;
      }
      .dark-mode
        .order-type-selection
        input[type="radio"]:checked
        + .order-type-option {
        background-color: #333;
        border-color: #ff6200;
        color: #ff6200;
      }

      .dark-mode-toggle {
        position: fixed;
        top: 18px;
        right: 24px;
        z-index: 2000;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(135deg, #232526 60%, #ff6200 100%);
        color: #fff;
        border: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        font-size: 22px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.3s, color 0.3s, box-shadow 0.3s;
      }
      .dark-mode-toggle:hover {
        background: linear-gradient(135deg, #ff6200 60%, #232526 100%);
        color: #ffd700;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      }

      .comp-reason-animated-popup {
        display: none;
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.25);
        z-index: 3000;
        align-items: center;
        justify-content: center;
        animation: fadeInBg 0.4s;
      }
      .comp-reason-animated-popup.show {
        display: flex;
      }
      .comp-reason-popup-content {
        background: #fff;
        color: #222;
        border-radius: 18px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
        padding: 32px 36px 24px 36px;
        min-width: 320px;
        max-width: 90vw;
        text-align: center;
        animation: popIn 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
      }
      .comp-reason-popup-content h3 {
        font-size: 1.5em;
        margin-bottom: 18px;
        color: #ff6200;
        letter-spacing: 1px;
      }
      .dark-mode .comp-reason-popup-content {
        background: #232526;
        color: #ffd580;
      }
      @keyframes popIn {
        0% {
          transform: scale(0.7);
          opacity: 0;
        }
        80% {
          transform: scale(1.05);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      @keyframes fadeInBg {
        0% {
          background: rgba(0, 0, 0, 0);
        }
        100% {
          background: rgba(0, 0, 0, 0.25);
        }
      }

      .contact-driver-popup {
        display: none;
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.25);
        z-index: 3000;
        align-items: center;
        justify-content: center;
        animation: fadeInBg 0.4s;
      }
      .contact-driver-popup.show {
        display: flex;
      }
      .contact-driver-popup-content {
        background: #fff;
        color: #222;
        border-radius: 18px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
        padding: 32px 36px 24px 36px;
        min-width: 340px;
        max-width: 95vw;
        text-align: center;
        animation: popIn 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
      }
      .contact-driver-popup-content h3 {
        font-size: 1.3em;
        margin-bottom: 18px;
        color: #ff6200;
        letter-spacing: 1px;
      }
      .dark-mode .contact-driver-popup-content {
        background: #232526;
        color: #ffd580;
      }

      .contact-driver-fab {
        position: fixed;
        left: 20px;
        top: 10px; /* Adjust this value to be just above Failed Trials (which starts at top: 300px) */
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff6200 60%, #ffb366 100%);
        color: #fff;
        border: none;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 3500;
        transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      }
      .contact-driver-fab:hover {
        background: linear-gradient(135deg, #ffb366 60%, #ff6200 100%);
        color: #232526;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      }
      @media (max-width: 600px) {
        .contact-driver-fab {
          top: 18px;
          left: 18px;
          width: 50px;
          height: 50px;
          font-size: 1.5em;
        }
      }

      .fab-btns-top-left {
        position: fixed;
        top: 0px; /* Flush with top */
        left: 0px; /* Flush with left */
        z-index: 4000;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 8px;
      }
      @media (max-width: 600px) {
        .fab-btns-top-left {
          top: 0px;
          left: 0px;
          gap: 6px;
          padding: 4px;
        }
      }
      .contact-driver-fab,
      .sms-cst-fab {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff6200 60%, #ffb366 100%);
        color: #fff;
        border: none;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      }
      .contact-driver-fab:hover,
      .sms-cst-fab:hover {
        background: linear-gradient(135deg, #ffb366 60%, #ff6200 100%);
        color: #232526;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      }
      @media (max-width: 600px) {
        .fab-btns-top-left {
          top: 10px;
          left: 10px;
          gap: 10px;
        }
      }

      .sms-cst-popup {
        display: none;
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.25);
        z-index: 3000;
        align-items: center;
        justify-content: center;
        animation: fadeInBg 0.4s;
      }
      .sms-cst-popup.show {
        display: flex;
      }
      .sms-cst-popup-content {
        background: #fff;
        color: #222;
        border-radius: 18px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
        padding: 32px 36px 24px 36px;
        min-width: 340px;
        max-width: 95vw;
        text-align: center;
        animation: popIn 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
      }
      .sms-cst-popup-content h3 {
        font-size: 1.3em;
        margin-bottom: 18px;
        color: #ff6200;
        letter-spacing: 1px;
      }
      .dark-mode .sms-cst-popup-content {
        background: #232526;
        color: #ffd580;
      }

      .fab-btns-bottom-right {
        position: fixed;
        bottom: 24px;
        right: 24px;
        z-index: 4000;
        display: flex;
        flex-direction: row; /* side by side */
        gap: 16px;
        transition: opacity 0.3s;
        opacity: 0;
        pointer-events: none;
      }
      .fab-btns-bottom-right.show {
        opacity: 1;
        pointer-events: auto;
      }
      @media (max-width: 600px) {
        .fab-btns-bottom-right {
          bottom: 10px;
          right: 10px;
          gap: 8px;
        }
      }

      .floating-time-calc-btn {
        position: fixed;
        bottom: 60%;
        right: 32px;
        z-index: 200;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff6200 60%, #ffb366 100%);
        color: #fff;
        border: none;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      }
      .floating-time-calc-btn:hover {
        background: linear-gradient(135deg, #ffb366 60%, #ff6200 100%);
        color: #232526;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      }

      .floating-failed-trials-btn {
        position: fixed;
        top: 25%;
        left: 32px;
        z-index: 4101;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff3333 60%, #ffb366 100%);
        color: #fff;
        border: none;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      }
      .floating-failed-trials-btn:hover {
        background: linear-gradient(135deg, #ffb366 60%, #ff3333 100%);
        color: #232526;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      }
      @media (max-width: 600px) {
        .floating-failed-trials-btn {
          bottom: 70px;
          left: 12px;
          width: 44px;
          height: 44px;
          font-size: 1.3em;
        }
      }

      .floating-refund-sla-btn {
        position: fixed;
        bottom: 32%;
        left: 32px;
        z-index: 4102;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ffd700 60%, #ffb366 100%);
        color: #222;
        border: none;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      }
      .floating-refund-sla-btn:hover {
        background: linear-gradient(135deg, #ffb366 60%, #ffd700 100%);
        color: #18191a;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      }
      @media screen and (max-width: 600px) {
        .floating-time-calc-btn,
        .floating-refund-sla-btn {
          width: 44px;
          height: 44px;
        }
      }
        `;
        break;
        case 2:
                    // For tool #2
        containerStyle = `
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Arial, sans-serif;
        background: linear-gradient(135deg, #f5f7fa 0%, #e4e9f0 100%);
        min-height: 100vh;
        min-width: 100vw;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        overflow-x: hidden;
      }

      body.dark-mode {
        background: linear-gradient(135deg, #18191a 0%, #232526 100%);
        color: #f0f0f0;
      }

      .main-container {
        max-width: 98vw;
        width: 100%;
        margin: 2vw auto;
        padding: 30px 20px;
        background: #f8f8f8;
        border-radius: 24px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.1);
        position: relative;
      }
      body.dark-mode .main-container {
        background: #18191a;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      }

      .container {
        max-width: 500px;
        width: 100%;
        background: #ffffff;
        padding: 30px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
        z-index: 1;
        margin: 0 auto;
        transform: translateZ(10px);
      }

      .dark-mode .container {
        background: #232526;
        color: #f0f0f0;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
      }

      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        color: white;
        padding: 15px;
        border-radius: 12px;
        margin-bottom: 25px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .dark-mode .header {
        background: linear-gradient(90deg, #ff6200 80%, #232526 100%);
        color: #fff;
      }

      h2 {
        font-size: 24px;
        text-align: left;
        margin: 0;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }

      .reset-form-btn {
        background: linear-gradient(90deg, #ff1a1a, #ff4d4d);
        width: auto;
        padding: 8px 20px;
        font-size: 14px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: none;
        color: white;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      }

      .reset-form-btn:hover {
        background: linear-gradient(90deg, #e60000, #ff3333);
        transform: translateY(-2px) translateZ(5px);
        box-shadow: 0 5px 15px rgba(255, 26, 26, 0.4);
      }

      .dark-mode .reset-form-btn {
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        color: #fff;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
      }

      .dark-mode .reset-form-btn:hover {
        background: linear-gradient(90deg, #e65600, #ff8c00);
        color: #fff;
      }

      label {
        font-weight: 600;
        display: block;
        text-align: left;
        margin-bottom: 8px;
        color: #222;
      }

      .dark-mode label,
      .dark-mode .required-message {
        color: #ffd580;
      }

      input {
        width: 100%;
        padding: 12px;
        margin-bottom: 15px;
        border: 2px solid #ccc;
        border-radius: 10px;
        font-size: 16px;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        background: #f9f9f9;
      }

      .dark-mode input,
      .dark-mode select {
        background: #232526;
        color: #f0f0f0;
        border: 2px solid #666;
      }

      input:focus {
        border-color: #ff6200;
        outline: none;
        box-shadow: 0 0 8px rgba(255, 98, 0, 0.3);
      }

      .dark-mode input:focus,
      .dark-mode select:focus {
        border-color: #ff9a00;
        box-shadow: 0 0 8px #ff9a00;
      }

      input.invalid {
        border-color: #ff1a1a;
        animation: shake 0.3s ease-in-out;
      }

      .dark-mode input.invalid {
        border-color: #ff4d4d;
      }

      @keyframes shake {
        0% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        50% {
          transform: translateX(5px);
        }
        75% {
          transform: translateX(-5px);
        }
        100% {
          transform: translateX(0);
        }
      }

      button {
        width: 100%;
        padding: 12px;
        font-size: 16px;
        font-weight: 600;
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        color: white;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: none;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      button:hover {
        background: linear-gradient(90deg, #e65600, #ff8c00);
        transform: translateY(-2px) translateZ(5px);
        box-shadow: 0 8px 20px rgba(255, 98, 0, 0.4);
      }

      .dark-mode button,
      .dark-mode .reset-form-btn {
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        color: #fff;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
      }

      .dark-mode button:hover,
      .dark-mode .reset-form-btn:hover {
        background: linear-gradient(90deg, #e65600, #ff8c00);
        color: #fff;
      }

      button:disabled {
        background: #b0b0b0;
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
        box-shadow: none;
      }

      .dark-mode button:disabled {
        background: #444;
        color: #aaa;
      }

      #result {
        opacity: 0;
        transition: all 0.5s ease-in-out;
        margin-top: 20px;
        padding: 15px;
        border-radius: 12px;
        text-align: center;
        font-size: 20px;
        font-weight: 700;
        color: white;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        transform: translateZ(10px);
        position: relative;
      }

      .dark-mode #result {
        color: #fff;
        background: #333;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
      }

      #result.show {
        opacity: 1;
        transform: translateZ(15px) scale(1.02);
      }

      #compensation {
        position: fixed;
        left: -400px;
        top: 80px;
        width: 280px;
        background: linear-gradient(135deg, #ff3333, #ff6666);
        color: white;
        font-size: 16px;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        transition: left 0.5s ease-in-out;
        z-index: 2;
        text-align: left;
        transform: translateZ(10px);
      }

      .dark-mode #compensation {
        background: linear-gradient(135deg, #b34700, #ff6200);
        color: #fff;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.7);
      }

      #compensation.show {
        left: 20px;
      }

      #compensation h3 {
        font-size: 22px;
        margin-bottom: 15px;
        text-align: center;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }

      #compensation ul {
        padding-left: 20px;
        margin: 0;
      }

      #compensation ul li {
        margin-bottom: 8px;
        list-style: square;
      }

      #copyCompensationBtn {
        background: linear-gradient(90deg, #ffd700, #ffea00);
        color: #222;
        font-size: 16px;
        font-weight: 600;
        padding: 10px;
        margin-top: 15px;
        border-radius: 10px;
        cursor: pointer;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        animation: pulse 1.5s infinite;
        width: 100%;
        border: none;
        display: none;
      }

      .dark-mode #copyCompensationBtn {
        background: linear-gradient(90deg, #ffd700, #ffea00);
        color: #222;
      }

      @keyframes pulse {
        0% {
          transform: scale(1) translateZ(0);
        }
        50% {
          transform: scale(1.05) translateZ(5px);
        }
        100% {
          transform: scale(1) translateZ(0);
        }
      }

      .right-reminder {
        position: fixed;
        top: 100px;
        right: -400px;
        width: 280px;
        background: #fff5e6;
        color: #222;
        font-size: 16px;
        font-weight: 500;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        transition: right 0.5s ease-in-out;
        text-align: center;
        z-index: 3;
        transform: translateZ(10px);
      }

      .dark-mode .right-reminder {
        background: #232526;
        color: #ffd580;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.7);
      }

      .right-reminder.show {
        right: 20px;
      }

      .right-reminder .emoji {
        font-size: 50px;
        margin-bottom: 10px;
      }

      .right-reminder .paper {
        background-color: #fff;
        padding: 10px;
        margin-top: 10px;
        border-radius: 8px;
        border: 2px dashed #ff6200;
        font-weight: 600;
        font-size: 14px;
      }

      .third-reminder {
        position: fixed;
        top: 400px;
        left: -400px;
        width: 220px;
        background: linear-gradient(135deg, #ffd700, #ffea00);
        color: #222;
        font-size: 14px;
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        transition: left 0.5s ease-in-out;
        z-index: 1000;
        text-align: center;
        animation: shake 0.5s ease-in-out infinite;
        transform: translateZ(10px);
      }

      .dark-mode .third-reminder {
        background: linear-gradient(135deg, #b34700, #ffd700);
        color: #232526;
      }

      .third-reminder.show {
        left: 20px;
      }

      .third-reminder .emoji {
        font-size: 30px;
        margin-bottom: 5px;
      }

      .third-reminder h3 {
        font-size: 16px;
        margin-bottom: 5px;
      }

      .third-reminder p {
        margin: 5px 0;
      }

      #timeLeft {
        display: inline-block;
        font-size: 18px;
        font-weight: bold;
        color: #ff3333;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        background-color: #ffffff;
        padding: 5px 10px;
        border-radius: 5px;
        margin: 5px;
        animation: blink 1s infinite;
      }

      @keyframes blink {
        0% {
          background-color: #ffffff;
        }
        50% {
          background-color: #ff9999;
        }
        100% {
          background-color: #ffffff;
        }
      }

      @keyframes shake {
        0% {
          transform: translateX(0) translateZ(10px);
        }
        25% {
          transform: translateX(-5px) translateZ(10px);
        }
        50% {
          transform: translateX(5px) translateZ(10px);
        }
        75% {
          transform: translateX(-5px) translateZ(10px);
        }
        100% {
          transform: translateX(0) translateZ(10px);
        }
      }

      .time-calculator {
        position: fixed;
        top: 300px;
        right: 20px;
        width: 280px;
        background: linear-gradient(135deg, #ffe6cc, #fff5e6);
        color: #222;
        font-size: 16px;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        text-align: center;
        z-index: 3;
        transform: translateZ(10px);
      }

      .dark-mode .time-calculator {
        background: linear-gradient(135deg, #232526, #333);
        color: #fff;
      }

      .time-calculator h3 {
        font-size: 18px;
        margin-bottom: 15px;
        color: #ff6200;
      }

      .time-calculator input {
        margin-bottom: 10px;
        font-size: 14px;
      }

      .time-calculator button {
        font-size: 14px;
        padding: 10px;
      }

      .time-calculator #timeCalcResult {
        margin-top: 10px;
        font-size: 14px;
        font-weight: 600;
        color: #222;
        background-color: #fff;
        padding: 8px;
        border-radius: 8px;
        border: 2px dashed #ff6200;
      }

      .time-calculator #timeCalcResetCountdown {
        margin-top: 10px;
        color: #666;
        font-size: 12px;
        font-style: italic;
      }

      .time-calc-reminder {
        position: fixed;
        top: 460px;
        right: -400px;
        width: 280px;
        background: linear-gradient(135deg, #ffcc99, #ffdb80);
        color: #222;
        font-size: 16px;
        padding: 15px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        transition: right 0.5s ease-in-out;
        text-align: center;
        z-index: 3;
        transform: translateZ(10px);
      }

      .dark-mode .time-calc-reminder {
        background: linear-gradient(135deg, #b34700, #ffcc99);
        color: #fff;
      }

      .time-calc-reminder.show {
        right: 20px;
      }

      .time-calc-reminder p {
        font-weight: 600;
      }

      .time-calc-service-message {
        position: fixed;
        top: 510px;
        right: -400px;
        width: 280px;
        background: linear-gradient(135deg, #ff9999, #ffcccc);
        color: #222;
        font-size: 14px;
        padding: 15px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        transition: right 0.5s ease-in-out;
        text-align: center;
        z-index: 3;
        transform: translateZ(10px);
      }

      .dark-mode .time-calc-service-message {
        background: linear-gradient(135deg, #333, #ffb366);
        color: #fff;
      }

      .time-calc-service-message.show {
        right: 20px;
      }

      .time-calc-service-message p {
        font-weight: 600;
      }

      .time-calc-service-message .highlight {
        font-weight: bold;
        color: #ff3333;
      }

      .dark-mode .time-calc-service-message .highlight {
        color: #ffd700;
      }

      .failed-trials {
        position: fixed;
        left: -400px;
        top: 30%;
        width: 280px;
        background: linear-gradient(135deg, #ff9999, #ffcccc);
        color: #222;
        font-size: 16px;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        transition: left 0.5s ease-in-out;
        z-index: 2;
        text-align: left;
        transform: translateZ(10px);
      }

      .dark-mode .failed-trials {
        background: linear-gradient(135deg, #b34700, #ff9999);
        color: #fff;
      }

      .failed-trials.show {
        left: 20px;
      }

      .failed-trials h3 {
        font-size: 22px;
        margin-bottom: 15px;
        text-align: center;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
      }

      .failed-trials ul {
        padding-left: 20px;
        margin: 0;
      }

      .failed-trials ul li {
        margin-bottom: 8px;
        list-style: square;
      }

      .refund-sla-panel {
        position: fixed;
        bottom: 26%;
        left: -400px;
        width: 280px;
        background: linear-gradient(135deg, #fff5e6, #ffe6cc);
        color: #222;
        font-size: 16px;
        padding: 20px;
        border-radius: 15px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        text-align: center;
        z-index: 3;
        transform: translateZ(10px);
        transition: left 0.5s ease-in-out;
      }

      .dark-mode .refund-sla-panel {
        background: linear-gradient(135deg, #232526, #333);
        color: #ffd580;
      }

      .refund-sla-panel.show {
        left: 20px;
      }

      .refund-sla-panel h3 {
        font-size: 18px;
        margin-bottom: 15px;
        color: #ff6200;
      }

      .refund-sla-panel select {
        width: 100%;
        /*padding: 10px;*/
        font-size: 14px;
        border: 2px solid #ccc;
        border-radius: 10px;
        background: #f9f9f9;
        color: #222;
        cursor: pointer;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
        pointer-events: auto;
      }

      .dark-mode .refund-sla-panel select {
        background: #2d2f31;
        color: #fff;
        border: 2px solid #444;
      }

      .refund-sla-panel select:focus {
        border-color: #ff6200;
        outline: none;
        box-shadow: 0 0 8px rgba(255, 98, 0, 0.3);
      }

      .refund-sla-details {
        position: absolute;
        top: 100px;
        left: 0;
        right: 0;
        width: 240px;
        margin: 0 auto;
        background: #fff;
        color: #222;
        font-size: 14px;
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        transform: translateY(-20px);
        opacity: 0;
        transition: all 0.5s ease-in-out;
        z-index: 4;
        border: 2px dashed #ff6200;
        direction: rtl;
        text-align: right;
      }

      .dark-mode .refund-sla-details {
        background: #232526;
        color: #fff;
        border-color: #ff6200;
      }

      .refund-sla-details.show {
        transform: translateY(0);
        opacity: 1;
      }

      .refund-sla-details p {
        margin: 8px 0;
        font-weight: 500;
      }

      .refund-sla-details .highlight {
        font-weight: bold;
        color: #ff6200;
      }

      .marquee {
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        color: white;
        font-size: 16px;
        padding: 10px 0;
        overflow: hidden;
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        z-index: 999;
        box-shadow: 0 -5px 15px rgba(0, 0, 0, 0.2);
      }

      .dark-mode .marquee {
        background: linear-gradient(90deg, #ff6200, #232526);
        color: #ffd580;
      }

      .marquee-text {
        display: inline-block;
        white-space: nowrap;
        padding-left: 100%;
        animation: scroll 80s linear infinite;
      }

      @keyframes scroll {
        0% {
          transform: translateX(0);
        }
        100% {
          transform: translateX(-100%);
        }
      }

      #orderTimers {
        margin-top: 30px;
      }

      .service-selection {
        display: flex;
        justify-content: space-between;
        margin: 20px 0 25px;
        gap: 10px;
      }

      .service-option {
        flex: 1;
        text-align: center;
        position: relative;
        cursor: pointer;
      }

      .service-option input[type="checkbox"] {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
      }

      .service-option label {
        display: block;
        background-color: #f0f0f0;
        border: 2px solid #ccc;
        border-radius: 10px;
        padding: 12px 8px;
        font-size: 14px;
        font-weight: 600;
        color: #444;
        transition: all 0.3s ease;
        cursor: pointer;
        text-align: center;
      }

      .dark-mode .service-option label {
        background-color: #232526;
        border: 2px solid #666;
        color: #ffd580;
      }

      .service-option:nth-child(1) label {
        color: #ff6200;
      }

      .service-option:nth-child(2) label {
        color: #0066cc;
      }

      .service-option:nth-child(3) label {
        color: #990099;
      }

      .service-option input[type="checkbox"]:checked + label {
        background-color: #fff;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        transform: translateY(-3px) translateZ(5px);
        border-color: currentColor;
      }

      .dark-mode .service-option input[type="checkbox"]:checked + label {
        background-color: #333;
        border-color: #ff6200;
        color: #ff6200;
      }

      .service-option:nth-child(1) input[type="checkbox"]:checked + label {
        background-color: #fff5e6;
      }

      .service-option:nth-child(2) input[type="checkbox"]:checked + label {
        background-color: #e6f0ff;
      }

      .service-option:nth-child(3) input[type="checkbox"]:checked + label {
        background-color: #f5e6ff;
      }

      #resetCountdown {
        margin-top: 15px;
        color: #666;
        font-size: 14px;
        font-style: italic;
        text-align: center;
      }

      .required-message {
        color: #ff3333;
        font-size: 13px;
        text-align: center;
        margin-top: -10px;
        margin-bottom: 10px;
        font-style: italic;
      }

      .dark-mode .required-message {
        color: #ffd580;
      }

      .order-timer-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background-color: #f0f0f0;
        padding: 12px 15px;
        border-radius: 10px;
        margin-bottom: 10px;
        transition: all 0.3s ease;
        box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
      }

      .dark-mode .order-timer-item {
        background: #232526;
        color: #fff;
      }

      .order-timer-item.completed {
        background-color: #e6ffcc;
        color: #006600;
        text-decoration: line-through;
      }

      .dark-mode .order-timer-item.completed {
        background: #2d2f31;
        color: #00cc00;
      }

      .order-timer-checkbox {
        margin-right: 10px;
        transform: scale(1.5);
        cursor: pointer;
      }

      .dark-mode .order-timer-checkbox {
        accent-color: #ff9a00;
      }

      .order-timer-content {
        flex-grow: 1;
        text-align: left;
        margin-left: 8px;
        display: flex;
        align-items: center;
      }

      .timer-display {
        margin-left: 10px;
        font-weight: 600;
      }

      .timer-progress {
        width: 50px;
        height: 10px;
        background-color: #ccc;
        border-radius: 5px;
        overflow: hidden;
        margin-left: 10px;
      }

      .dark-mode .timer-progress {
        background-color: #444;
      }

      .timer-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #ff6200, #ff9a00);
        transition: width 1s linear;
      }

      .dark-mode .timer-progress-bar {
        background: linear-gradient(90deg, #ff6200, #ff9a00);
      }

      .timer-controls {
        display: flex;
        align-items: center;
      }

      .delete-timer {
        background: none;
        border: none;
        color: #ff3333;
        cursor: pointer;
        font-size: 18px;
        padding: 0 8px;
        margin-left: 8px;
        width: auto;
      }

      .dark-mode .delete-timer {
        color: #ff4d4d;
      }

      .order-type-selection {
        display: flex;
        gap: 10px;
        margin-top: 8px;
      }
      .order-type-selection input[type="radio"] {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
      }
      .order-type-option {
        flex: 1;
        text-align: center;
        background-color: #f0f0f0;
        border: 2px solid #ccc;
        border-radius: 10px;
        padding: 12px 8px;
        font-size: 14px;
        font-weight: 600;
        color: #444;
        transition: all 0.3s ease;
        cursor: pointer;
        user-select: none;
      }
      .dark-mode .order-type-option {
        background-color: #232526;
        border: 2px solid #666;
        color: #ffd580;
      }
      .order-type-selection input[type="radio"]:checked + .order-type-option {
        background-color: #fff5e6;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        transform: translateY(-3px) translateZ(5px);
        border-color: #ff6200;
        color: #ff6200;
      }
      .dark-mode
        .order-type-selection
        input[type="radio"]:checked
        + .order-type-option {
        background-color: #333;
        border-color: #ff6200;
        color: #ff6200;
      }

      .dark-mode-toggle {
        position: fixed;
        top: 18px;
        right: 24px;
        z-index: 2000;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: linear-gradient(135deg, #232526 60%, #ff6200 100%);
        color: #fff;
        border: none;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        font-size: 22px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.3s, color 0.3s, box-shadow 0.3s;
      }
      .dark-mode-toggle:hover {
        background: linear-gradient(135deg, #ff6200 60%, #232526 100%);
        color: #ffd700;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      }

      .comp-reason-animated-popup {
        display: none;
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.25);
        z-index: 3000;
        align-items: center;
        justify-content: center;
        animation: fadeInBg 0.4s;
      }
      .comp-reason-animated-popup.show {
        display: flex;
      }
      .comp-reason-popup-content {
        background: #fff;
        color: #222;
        border-radius: 18px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
        padding: 32px 36px 24px 36px;
        min-width: 320px;
        max-width: 90vw;
        text-align: center;
        animation: popIn 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
      }
      .comp-reason-popup-content h3 {
        font-size: 1.5em;
        margin-bottom: 18px;
        color: #ff6200;
        letter-spacing: 1px;
      }
      .dark-mode .comp-reason-popup-content {
        background: #232526;
        color: #ffd580;
      }
      @keyframes popIn {
        0% {
          transform: scale(0.7);
          opacity: 0;
        }
        80% {
          transform: scale(1.05);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }
      @keyframes fadeInBg {
        0% {
          background: rgba(0, 0, 0, 0);
        }
        100% {
          background: rgba(0, 0, 0, 0.25);
        }
      }

      .contact-driver-popup {
        display: none;
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.25);
        z-index: 3000;
        align-items: center;
        justify-content: center;
        animation: fadeInBg 0.4s;
      }
      .contact-driver-popup.show {
        display: flex;
      }
      .contact-driver-popup-content {
        background: #fff;
        color: #222;
        border-radius: 18px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
        padding: 32px 36px 24px 36px;
        min-width: 340px;
        max-width: 95vw;
        text-align: center;
        animation: popIn 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
      }
      .contact-driver-popup-content h3 {
        font-size: 1.3em;
        margin-bottom: 18px;
        color: #ff6200;
        letter-spacing: 1px;
      }
      .dark-mode .contact-driver-popup-content {
        background: #232526;
        color: #ffd580;
      }

      .contact-driver-fab {
        position: fixed;
        left: 20px;
        top: 10px; /* Adjust this value to be just above Failed Trials (which starts at top: 300px) */
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff6200 60%, #ffb366 100%);
        color: #fff;
        border: none;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 3500;
        transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      }
      .contact-driver-fab:hover {
        background: linear-gradient(135deg, #ffb366 60%, #ff6200 100%);
        color: #232526;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      }
      @media (max-width: 600px) {
        .contact-driver-fab {
          top: 18px;
          left: 18px;
          width: 50px;
          height: 50px;
          font-size: 1.5em;
        }
      }

      .fab-btns-top-left {
        position: fixed;
        top: 0px; /* Flush with top */
        left: 0px; /* Flush with left */
        z-index: 4000;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 8px;
      }
      @media (max-width: 600px) {
        .fab-btns-top-left {
          top: 0px;
          left: 0px;
          gap: 6px;
          padding: 4px;
        }
      }
      .contact-driver-fab,
      .sms-cst-fab {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff6200 60%, #ffb366 100%);
        color: #fff;
        border: none;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      }
      .contact-driver-fab:hover,
      .sms-cst-fab:hover {
        background: linear-gradient(135deg, #ffb366 60%, #ff6200 100%);
        color: #232526;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      }
      @media (max-width: 600px) {
        .fab-btns-top-left {
          top: 10px;
          left: 10px;
          gap: 10px;
        }
      }

      .sms-cst-popup {
        display: none;
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.25);
        z-index: 3000;
        align-items: center;
        justify-content: center;
        animation: fadeInBg 0.4s;
      }
      .sms-cst-popup.show {
        display: flex;
      }
      .sms-cst-popup-content {
        background: #fff;
        color: #222;
        border-radius: 18px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
        padding: 32px 36px 24px 36px;
        min-width: 340px;
        max-width: 95vw;
        text-align: center;
        animation: popIn 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
      }
      .sms-cst-popup-content h3 {
        font-size: 1.3em;
        margin-bottom: 18px;
        color: #ff6200;
        letter-spacing: 1px;
      }
      .dark-mode .sms-cst-popup-content {
        background: #232526;
        color: #ffd580;
      }

      .fab-btns-bottom-right {
        position: fixed;
        bottom: 24px;
        right: 24px;
        z-index: 4000;
        display: flex;
        flex-direction: row; /* side by side */
        gap: 16px;
        transition: opacity 0.3s;
        opacity: 0;
        pointer-events: none;
      }
      .fab-btns-bottom-right.show {
        opacity: 1;
        pointer-events: auto;
      }
      @media (max-width: 600px) {
        .fab-btns-bottom-right {
          bottom: 10px;
          right: 10px;
          gap: 8px;
        }
      }

      .floating-time-calc-btn {
        position: fixed;
        bottom: 60%;
        right: 32px;
        z-index: 200;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff6200 60%, #ffb366 100%);
        color: #fff;
        border: none;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      }
      .floating-time-calc-btn:hover {
        background: linear-gradient(135deg, #ffb366 60%, #ff6200 100%);
        color: #232526;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      }

      .floating-failed-trials-btn {
        position: fixed;
        top: 25%;
        left: 32px;
        z-index: 4101;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ff3333 60%, #ffb366 100%);
        color: #fff;
        border: none;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      }
      .floating-failed-trials-btn:hover {
        background: linear-gradient(135deg, #ffb366 60%, #ff3333 100%);
        color: #232526;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      }
      @media (max-width: 600px) {
        .floating-failed-trials-btn {
          bottom: 70px;
          left: 12px;
          width: 44px;
          height: 44px;
          font-size: 1.3em;
        }
      }

      .floating-refund-sla-btn {
        position: fixed;
        bottom: 32%;
        left: 32px;
        z-index: 4102;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: linear-gradient(135deg, #ffd700 60%, #ffb366 100%);
        color: #222;
        border: none;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.18);
        font-size: 2em;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background 0.2s, box-shadow 0.2s, color 0.2s;
      }
      .floating-refund-sla-btn:hover {
        background: linear-gradient(135deg, #ffb366 60%, #ffd700 100%);
        color: #18191a;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
      }
      @media screen and (max-width: 600px) {
        .floating-time-calc-btn,
        .floating-refund-sla-btn {
          width: 44px;
          height: 44px;
        }
      }
        `;
        break;
        case 3:
                    // For tool #3
        containerStyle = `
        :root {
            --primary-color: #6a21a8;
            --primary-light: #9c64c8;
            --primary-dark: #4a148c;
            --text-color: #333;
            --bg-color: #f8f5ff;
            --card-bg: white;
            --border-color: #e0d0f0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            position: relative;
        }
        
        .header {
            background-color: var(--primary-dark);
            color: white;
            padding: 15px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        
        .logo {
            height: 50px;
        }
        
        .header-text {
            text-align: left;
        }
        
        .header h1 {
            margin: 0;
            font-size: 1.8rem;
        }
        
        .header p {
            margin: 5px 0 0;
            font-style: italic;
            opacity: 0.9;
        }
        
        .container {
            display: flex;
            gap: 25px;
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 20px;
        }
        
        .editor-section {
            flex: 2;
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(106, 33, 168, 0.1);
            border: 1px solid var(--border-color);
            transition: margin-right 0.3s ease;
        }
        
        .quick-actions {
            flex: 1;
            background: var(--card-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(106, 33, 168, 0.1);
            border: 1px solid var(--border-color);
            overflow-y: auto;
            max-height: 80vh;
            position: fixed;
            right: -400px;
            top: 100px;
            width: 350px;
            height: calc(100vh - 150px);
            transition: right 0.3s ease;
            z-index: 100;
        }
        
        .quick-actions.visible {
            right: 20px;
        }
        
        .sidebar-handle {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 80px;
            background-color: var(--primary-color);
            border-radius: 5px 0 0 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            z-index: 99;
        }
        
        h2 {
            color: var(--primary-color);
            border-bottom: 2px solid #f0e5ff;
            padding-bottom: 12px;
            margin-top: 0;
            font-size: 1.5rem;
        }
        
        textarea {
            width: 100%;
            height: 180px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            resize: vertical;
            font-size: 14px;
            background-color: #fefcff;
            transition: border 0.3s;
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--primary-light);
            box-shadow: 0 0 0 2px rgba(156, 100, 200, 0.2);
        }
        
        .action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .action-btn {
            padding: 8px 14px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
        }
        
        .action-btn:hover {
            background-color: var(--primary-light);
            transform: translateY(-1px);
        }
        
        .action-btn:active {
            transform: translateY(0);
        }
        
        .action-btn .tooltip {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
        }
        
        .action-btn:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }
        
        .section-title {
            font-weight: 600;
            margin-top: 20px;
            color: var(--primary-color);
            font-size: 15px;
            cursor: grab;
            padding: 5px;
            border-radius: 4px;
            background-color: #f0e5ff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .section-title:hover {
            background-color: #e0d0f0;
        }
        
        .section-title.dragging {
            cursor: grabbing;
            background-color: #d0c0e0;
        }
        
        .autocomplete-suggestions {
            border: 1px solid var(--border-color);
            max-height: 200px;
            overflow-y: auto;
            display: none;
            position: absolute;
            background: var(--card-bg);
            z-index: 1000;
            width: calc(100% - 26px);
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .autocomplete-suggestion {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0e5ff;
        }
        
        .autocomplete-suggestion:hover, .autocomplete-suggestion.selected {
            background-color: #f8f0ff;
        }
        
        .autocomplete-suggestion b {
            color: var(--primary-color);
            font-weight: 600;
        }
        
        #copyBtn, #generateBtn, #saveTemplateBtn, #resetBtn {
            background-color: var(--primary-dark);
            padding: 10px 20px;
            font-size: 14px;
            margin-top: 10px;
            width: 100%;
        }
        
        #copyBtn:hover, #generateBtn:hover, #saveTemplateBtn:hover, #resetBtn:hover {
            background-color: var(--primary-color);
        }
        
        .keyword-hint {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
            font-style: italic;
        }
        
        .footer {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            color: #666;
            font-size: 12px;
            border-top: 1px solid #eee;
        }
        
        .footer span {
            color: var(--primary-color);
            font-weight: 600;
        }
        
        /* Flag specific colors */
        .flag-red {
            background-color: #ff4444;
        }
        
        .flag-orange {
            background-color: #ff9900;
        }
        
        .flag-green {
            background-color: #00aa44;
        }
        
        .flag-red:hover {
            background-color: #cc0000;
        }
        
        .flag-orange:hover {
            background-color: #cc7a00;
        }
        
        .flag-green:hover {
            background-color: #00802b;
        }
        
        /* Preview section styles */
        .preview-section {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background-color: #fefcff;
            display: none;
        }
        
        .preview-section h3 {
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 10px;
        }
        
        .preview-content {
            white-space: pre-wrap;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.5;
        }
        
        .spelling-error {
            background-color: #ffdddd;
            border-bottom: 1px dashed #ff4444;
            cursor: pointer;
        }
        
        .grammar-error {
            background-color: #ffffcc;
            border-bottom: 1px dashed #ff9900;
            cursor: pointer;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .button-group button {
            flex: 1;
        }
        
        /* History & Search section */
        .history-section {
            margin-top: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            background-color: #fefcff;
        }
        
        .history-item {
            padding: 8px;
            border-bottom: 1px solid #f0e5ff;
            cursor: pointer;
        }
        
        .history-item:hover {
            background-color: #f8f0ff;
        }
        
        .history-item:last-child {
            border-bottom: none;
        }
        
        #historySearch {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        /* Templates section */
        .templates-section {
            margin-top: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            background-color: #fefcff;
        }
        
        .template-item {
            padding: 8px;
            border-bottom: 1px solid #f0e5ff;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .template-item:hover {
            background-color: #f8f0ff;
        }
        
        .template-item:last-child {
            border-bottom: none;
        }
        
        .delete-template {
            color: #ff4444;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .delete-template:hover {
            background-color: #ffdddd;
        }
        
        /* Smart Shortcuts indicator */
        .shortcut-hint {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
            font-style: italic;
        }
        
        /* Drag and drop placeholder */
        .drag-placeholder {
            border: 2px dashed var(--primary-light);
            background-color: #f8f0ff;
            height: 40px;
            margin: 5px 0;
            border-radius: 4px;
        }
        
        /* New styles for quick action customization */
        .quick-actions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        #quickActionsSearch {
            width: 60%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        #addQuickActionBtn {
            padding: 8px 12px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        
        #addQuickActionBtn:hover {
            background-color: var(--primary-light);
        }
        
        .action-btn.dragging {
            opacity: 0.5;
        }
        
        .action-btn.drag-over {
            border: 2px dashed var(--primary-light);
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        
        .modal-content {
            background-color: var(--card-bg);
            margin: 15% auto;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .modal-header h3 {
            margin: 0;
            color: var(--primary-color);
        }
        
        .close-modal {
            color: #aaa;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-modal:hover {
            color: var(--text-color);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        
        .modal-footer button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #saveQuickActionBtn {
            background-color: var(--primary-color);
            color: white;
        }
        
        #saveQuickActionBtn:hover {
            background-color: var(--primary-light);
        }
        
        #cancelQuickActionBtn {
            background-color: #f0e5ff;
            color: var(--primary-color);
        }
        
        #cancelQuickActionBtn:hover {
            background-color: #e0d0f0;
        }
        `;
        break;
    }

      styleTag.textContent = containerStyle;
      document.head.appendChild(styleTag);

      // إخفاء الأزرار
      document.getElementById("main-button-container").style.display = "none";

      // إخفاء كل الكونتينرات
      document.querySelectorAll(".tool-container").forEach(el => el.style.display = "none");

      // إظهار الكونتينر المطلوب
      document.getElementById("container-" + buttonId).style.display = "block";
    }

    function resetPage() {
      // إزالة أي style قديم
      const existingStyle = document.querySelector("style[data-dynamic]");
      if (existingStyle) existingStyle.remove();

      // إخفاء الكونتينرات
      document.querySelectorAll(".tool-container").forEach(el => el.style.display = "none");

      // إظهار الأزرار الرئيسية
      document.getElementById("main-button-container").style.display = "flex";
    }
  </script>
    <script>
    const activeOrders = {};
    let formResetTimer = null;
    let thirdReminderTimer = null;
    let timeLeftInterval = null;
    let timeCalcReminderTimer = null;
    let timeCalcResetTimer = null;
    let timeCalcServiceMessageTimer = null;

    document.addEventListener("DOMContentLoaded", function () {
      document
        .getElementById("chatStart")
        .addEventListener("keypress", handleEnterKey);
      document
        .getElementById("orderPlacing")
        .addEventListener("keypress", handleEnterKey);
      document
        .getElementById("orderDelivery")
        .addEventListener("keypress", handleEnterKey);
      document
        .getElementById("orderIdInput")
        .addEventListener("keypress", (e) => {
          if (e.key === "Enter") startCountdown();
        });
      document
        .getElementById("endTimeInput")
        .addEventListener("keypress", (e) => {
          if (e.key === "Enter") calculateNewTime();
        });
      updateCalculateButtonState();
      adjustTimeCalcReminderPosition();
      adjustTimeCalcServiceMessagePosition();
      //adjustRefundSlaPanelPosition();
    });

    function handleEnterKey(event) {
      if (event.key === "Enter") {
        event.preventDefault();
        const chatInput = document.getElementById("chatStart");
        const orderInput = document.getElementById("orderPlacing");
        const deliveryInput = document.getElementById("orderDelivery");
        const chatValue = chatInput.value.trim();
        const orderValue = orderInput.value.trim();
        const deliveryValue = parseFloat(deliveryInput.value);
        const serviceSelected = document.querySelector(
          'input[name="compGroup"]:checked'
        );

        chatInput.classList.remove("invalid");
        orderInput.classList.remove("invalid");
        deliveryInput.classList.remove("invalid");

        let isValid = true;

        if (!chatValue) {
          chatInput.classList.add("invalid");
          isValid = false;
        }
        if (!orderValue) {
          orderInput.classList.add("invalid");
          isValid = false;
        }
        if (isNaN(deliveryValue) || deliveryValue <= 0) {
          deliveryInput.classList.add("invalid");
          isValid = false;
        }
        if (!serviceSelected) {
          const serviceMsg = document.getElementById("serviceRequiredMsg");
          serviceMsg.style.fontWeight = "bold";
          setTimeout(() => {
            serviceMsg.style.fontWeight = "normal";
          }, 1000);
          isValid = false;
        }

        if (isValid) {
          calculateDelay();
        }
      }
    }

    function updateCalculateButtonState() {
      const serviceSelected = document.querySelector(
        'input[name="compGroup"]:checked'
      );
      const orderTypeDiv = document.getElementById("fvNfvSelection");
      const orderTypeRequired =
        orderTypeDiv && orderTypeDiv.style.display !== "none";
      const orderTypeSelected = document.querySelector(
        'input[name="orderType"]:checked'
      );
      const calculateBtn = document.getElementById("calculateBtn");
      let enable = false;
      if (serviceSelected) {
        if (
          serviceSelected.value === "tmp" ||
          serviceSelected.value === "tgo"
        ) {
          enable = !!orderTypeSelected;
        } else {
          enable = true;
        }
      }
      calculateBtn.disabled = !enable;
      calculateBtn.style.display = enable ? "block" : "none";
      document.getElementById("serviceRequiredMsg").style.display =
        serviceSelected ? "none" : "block";
      if (!serviceSelected) {
        document
          .getElementById("timeCalcServiceMessage")
          .classList.remove("show");
      }
    }

    function parseChatTime(input) {
      try {
        const [datePart, timePart] = input.split(", ");
        const [day, month, year] = datePart.split(".");
        return new Date(`${year}-${month}-${day} ${timePart}`);
      } catch (e) {
        return null;
      }
    }

    function parseOrderTime(input) {
      try {
        if (input.includes(",")) {
          const [datePart, timePart] = input.split(", ");
          const [day, month, year] = datePart.split(".");
          return new Date(`${year}-${month}-${day} ${timePart}`);
        }
        return new Date(input);
      } catch (e) {
        return null;
      }
    }

    function copyTextToClipboard(text, elementId) {
      navigator.clipboard.writeText(text).then(
        () => {
          const element = document.getElementById(elementId);
          const originalText = element.innerText;
          element.innerText = originalText + " ✓ Copied!";
          setTimeout(() => {
            element.innerText = originalText;
          }, 2000);
        },
        () => {
          alert("Failed to copy text. Please try again.");
        }
      );
    }

    function copyCompensationText() {
      const text =
        "كاعتذار مننا سوف نقوم بإضافة مبلغ كقسيمة على محفظة القسائم تقدر تستخدمها مع الطلبات الكاش والاونلاين عن طريق التطبيق";
      copyTextToClipboard(text, "copyCompensationBtn");
    }

    function cleanupTimers() {
      if (formResetTimer) {
        clearTimeout(formResetTimer);
        formResetTimer = null;
      }
      if (thirdReminderTimer) {
        clearTimeout(thirdReminderTimer);
        thirdReminderTimer = null;
      }
      if (timeLeftInterval) {
        clearInterval(timeLeftInterval);
        timeLeftInterval = null;
      }
      if (timeCalcReminderTimer) {
        clearTimeout(timeCalcReminderTimer);
        timeCalcReminderTimer = null;
        document.getElementById("timeCalcReminder").classList.remove("show");
      }
      if (timeCalcResetTimer) {
        clearTimeout(timeCalcResetTimer);
        timeCalcResetTimer = null;
        document.getElementById("timeCalcResetCountdown").innerText = "";
      }
      if (timeCalcServiceMessageTimer) {
        clearTimeout(timeCalcServiceMessageTimer);
        timeCalcServiceMessageTimer = null;
        document
          .getElementById("timeCalcServiceMessage")
          .classList.remove("show");
      }
    }

    function resetFormFields(timeout = 300000) {
      cleanupTimers();

      let remainingTime = timeout / 1000;
      const container = document.querySelector(".container");

      const countdownElement =
        document.getElementById("resetCountdown") ||
        document.createElement("div");
      countdownElement.id = "resetCountdown";
      countdownElement.innerText = `Form will reset in ${remainingTime} seconds`;
      container.appendChild(countdownElement);

      if (timeout === 0) {
        remainingTime = 0;
        countdownElement.remove();
      } else {
        const countdownInterval = setInterval(() => {
          remainingTime--;
          countdownElement.innerText = `Form will reset in ${remainingTime} seconds`;
          if (remainingTime <= 0) clearInterval(countdownInterval);
        }, 1000);
      }

      formResetTimer = setTimeout(() => {
        document.getElementById("chatStart").value = "";
        document.getElementById("orderPlacing").value = "";
        document.getElementById("orderDelivery").value = "";
        document
          .querySelectorAll('input[name="compGroup"]')
          .forEach((checkbox) => {
            checkbox.checked = false;
          });
        updateCalculateButtonState();
        document.getElementById("result").style.opacity = "0";
        document.getElementById("result").classList.remove("show");
        document.getElementById("compensation").classList.remove("show");
        document.getElementById("rightReminder").classList.remove("show");
        document.getElementById("thirdReminder").classList.remove("show");
        document.getElementById("failedTrials").classList.add("show");
        document.getElementById("refundSlaPanel").classList.add("show");
        document.getElementById("copyCompensationBtn").style.display = "none";
        countdownElement.remove();
      }, timeout);
    }

    function startThirdReminder(minutesToCompensation, serviceType) {
      const thirdReminderPanel = document.getElementById("thirdReminder");
      const timeLeftSpan = document.getElementById("timeLeft");

      if (thirdReminderTimer) {
        clearTimeout(thirdReminderTimer);
        thirdReminderTimer = null;
      }
      if (timeLeftInterval) {
        clearInterval(timeLeftInterval);
        timeLeftInterval = null;
      }

      // Only show if within 15 minutes of compensation threshold
      if (minutesToCompensation <= 0 || minutesToCompensation > 15) {
        thirdReminderPanel.classList.remove("show");
        return;
      }

      thirdReminderPanel.classList.add("show");
      let remainingSeconds = minutesToCompensation * 60;
      timeLeftSpan.innerText = `${Math.floor(remainingSeconds / 60)
        .toString()
        .padStart(2, "0")}:${(remainingSeconds % 60)
        .toString()
        .padStart(2, "0")}`;

      timeLeftInterval = setInterval(() => {
        remainingSeconds--;
        if (remainingSeconds <= 0) {
          clearInterval(timeLeftInterval);
          timeLeftSpan.innerText = "00:00";
          thirdReminderPanel.classList.remove("show");
          // Show compensation panel when time runs out
          const compPanel = document.getElementById("compensation");
          const copyCompBtn = document.getElementById("copyCompensationBtn");
          document.querySelector(
            "#compensation h3"
          ).innerHTML = `⚠ ${serviceType} Required Compensation`;
          compPanel.classList.add("show");
          copyCompBtn.style.display = "block";
          return;
        }
        timeLeftSpan.innerText = `${Math.floor(remainingSeconds / 60)
          .toString()
          .padStart(2, "0")}:${(remainingSeconds % 60)
          .toString()
          .padStart(2, "0")}`;
      }, 1000);
    }

    function parseTimeString(timeStr) {
      const regex = /^(\d{1,2}):(\d{2})\s*(AM|PM)$/i;
      const match = timeStr.match(regex);
      if (!match) return null;

      let hours = parseInt(match[1], 10);
      const minutes = parseInt(match[2], 10);
      const period = match[3].toUpperCase();

      if (hours < 1 || hours > 12 || minutes > 59) return null;

      if (period === "PM" && hours !== 12) hours += 12;
      if (period === "AM" && hours === 12) hours = 0;

      const date = new Date();
      date.setHours(hours, minutes, 0, 0);
      return date;
    }

    function formatTime(date) {
      let hours = date.getHours();
      const minutes = date.getMinutes();
      const period = hours >= 12 ? "PM" : "AM";

      hours = hours % 12 || 12;
      return `${hours}:${minutes.toString().padStart(2, "0")}${period}`;
    }

    function adjustTimeCalcReminderPosition() {
      const timeCalculator = document.getElementById("timeCalculator");
      const timeCalcReminder = document.getElementById("timeCalcReminder");
      const rect = timeCalculator.getBoundingClientRect();
      const newTop = rect.top + rect.height + 20;
      timeCalcReminder.style.top = `${newTop}px`;
    }

    function adjustTimeCalcServiceMessagePosition() {
      const timeCalcReminder = document.getElementById("timeCalcReminder");
      const timeCalcServiceMessage = document.getElementById(
        "timeCalcServiceMessage"
      );
      const rect = timeCalcReminder.getBoundingClientRect();
      const newTop = rect.top + rect.height + 10;
      timeCalcServiceMessage.style.top = `${newTop}px`;
    }

    function adjustRefundSlaPanelPosition() {
      const failedTrials = document.getElementById("failedTrials");
      const refundSlaPanel = document.getElementById("refundSlaPanel");
      const rect = failedTrials.getBoundingClientRect();
      const newTop = rect.top + rect.height + 20;
      refundSlaPanel.style.top = `${newTop}px`;
    }

    function showRefundSlaDetails() {
      const selection = document.getElementById("paymentMethodSelect").value;
      const refundSlaDetails = document.getElementById("refundSlaDetails");
      const compensationScript =
        document.getElementById("compensationScript");

      refundSlaDetails.classList.remove("show");

      if (!selection) {
        return;
      }

      const slaData = {
        CreditCardKNet: "5-7",
        CreditCardEgypt: "2-7",
        Qpay: "7-21",
        Benefit: "5-7",
        ApplePay: "3",
        CreditCardOman: "5-7",
      };

      const slaDays = slaData[selection];
      //console.log("selection", selection);
      let scriptText = "";
      if (selection == "CreditCardOman") {
        scriptText =
          "هل تريد مني أن أعيد مبلغ طلبك إلى رصيد طلبات الخاص بك على الفور، فهو رصيد في حسابك على طلبات يمكنك استخدامه للطلب من أي مطعم يقبل الدفع الالكتروني  أو أم أن يتم رده على الحساب البنكي في خلال SLA يوم عمل؟";
      } else {
        scriptText =
          "هل تريد مني أن أعيد مبلغ طلبك إلى رصيد طلبات الخاص بك على الفور، فهو رصيد في حسابك على طلبات يمكنك استخدامه للطلب من أي مطعم يقبل الدفع الالكتروني وتنتهي صلاحيته بعد 12 شهر أو أم أن يتم رده على الحساب البنكي في خلال SLA يوم عمل؟";
      }

      scriptText = scriptText.replace("SLA", slaDays);
      compensationScript.innerText = scriptText;
      refundSlaDetails.classList.add("show");

      copyTextToClipboard(scriptText, "compensationScript");
    }

    function showTimeCalcReminder() {
      const timeCalcReminder = document.getElementById("timeCalcReminder");
      if (timeCalcReminderTimer) {
        clearTimeout(timeCalcReminderTimer);
        timeCalcReminder.classList.remove("show");
      }

      timeCalcReminder.classList.add("show");
      timeCalcReminderTimer = setTimeout(() => {
        timeCalcReminder.classList.remove("show");
        timeCalcReminderTimer = null;
      }, 10000);
    }

    function showTimeCalcServiceMessage() {
      const selectedType = document.querySelector(
        'input[name="compGroup"]:checked'
      )?.value;
      const serviceMessageContent = document.getElementById(
        "serviceMessageContent"
      );
      const timeCalcServiceMessage = document.getElementById(
        "timeCalcServiceMessage"
      );

      if (!selectedType) {
        timeCalcServiceMessage.classList.remove("show");
        return;
      }

      if (selectedType === "tgo") {
        serviceMessageContent.innerHTML =
          '<span class="highlight" style="font-weight:bold;">(Rider RNA)</span> If order picked up send to CST end time +10 min';
        timeCalcServiceMessage.classList.add("show");
      } else {
        timeCalcServiceMessage.classList.remove("show");
      }
    }

    function resetTimeCalculator() {
      if (timeCalcResetTimer) {
        clearTimeout(timeCalcResetTimer);
        timeCalcResetTimer = null;
      }
      if (timeCalcReminderTimer) {
        clearTimeout(timeCalcReminderTimer);
        timeCalcReminderTimer = null;
        document.getElementById("timeCalcReminder").classList.remove("show");
      }

      const countdownElement = document.getElementById(
        "timeCalcResetCountdown"
      );
      let remainingTime = 60;

      countdownElement.innerText = `Calculator will reset in ${remainingTime} seconds`;

      const countdownInterval = setInterval(() => {
        remainingTime--;
        countdownElement.innerText = `Calculator will reset in ${remainingTime} seconds`;
        if (remainingTime <= 0) {
          clearInterval(countdownInterval);
        }
      }, 1000);

      timeCalcResetTimer = setTimeout(() => {
        document.getElementById("endTimeInput").value = "";
        document.getElementById("timeCalcResult").innerText = "";
        countdownElement.innerText = "";
      }, 60000);
    }

    function calculateNewTime() {
      const endTimeInput = document.getElementById("endTimeInput");
      const timeCalcResult = document.getElementById("timeCalcResult");
      const timeCalcBtn = document.getElementById("timeCalcBtn");
      const timeStr = endTimeInput.value.trim();

      endTimeInput.classList.remove("invalid");

      const parsedTime = parseTimeString(timeStr);
      if (!parsedTime) {
        endTimeInput.classList.add("invalid");
        timeCalcResult.innerText = "Invalid time format. Use Ex, 10:25 AM";
        return;
      }

      parsedTime.setMinutes(parsedTime.getMinutes() + 10);
      const newTime = formatTime(parsedTime);
      timeCalcResult.innerText = `New Time: ${newTime}`;

      const copyText = `${timeStr} - ${newTime}`;
      navigator.clipboard.writeText(copyText).then(
        () => {
          const originalText = timeCalcBtn.textContent;
          timeCalcBtn.textContent = "Copied!";
          setTimeout(() => {
            timeCalcBtn.textContent = originalText;
          }, 2000);
        },
        () => {
          alert("Failed to copy time. Please try again.");
        }
      );

      resetTimeCalculator();
      showTimeCalcReminder();
    }

    function calculateDelay() {
      resetFormFields(300000);

      const chatInput = document.getElementById("chatStart").value.trim();
      const orderInput = document.getElementById("orderPlacing").value.trim();
      const deliveryMins = parseFloat(
        document.getElementById("orderDelivery").value
      );
      const resultDiv = document.getElementById("result");
      const compPanel = document.getElementById("compensation");
      const rightReminderPanel = document.getElementById("rightReminder");
      const thirdReminderPanel = document.getElementById("thirdReminder");
      const failedTrialsPanel = document.getElementById("failedTrials");
      const refundSlaPanel = document.getElementById("refundSlaPanel");
      const copyCompBtn = document.getElementById("copyCompensationBtn");
      const selectedType = document.querySelector(
        'input[name="compGroup"]:checked'
      )?.value;
      const selectedOrderType = document.querySelector(
        'input[name="orderType"]:checked'
      )?.value;

      if (
        !chatInput ||
        !orderInput ||
        isNaN(deliveryMins) ||
        deliveryMins <= 0
      ) {
        resultDiv.innerHTML =
          "⚠ Invalid Input: Ensure all fields are filled and delivery time is positive";
        resultDiv.style.backgroundColor = "#ff3333";
        resultDiv.style.opacity = "1";
        resultDiv.classList.add("show");
        failedTrialsPanel.classList.remove("show");
        refundSlaPanel.classList.remove("show");
        return;
      }

      if (
        (selectedType === "tmp" || selectedType === "tgo") &&
        !selectedOrderType
      ) {
        resultDiv.innerHTML = "⚠ Please select FV & tMart or NFV order type.";
        resultDiv.style.backgroundColor = "#ff3333";
        resultDiv.style.opacity = "1";
        resultDiv.classList.add("show");
        failedTrialsPanel.classList.remove("show");
        refundSlaPanel.classList.remove("show");
        return;
      }

      const chatTime = parseChatTime(chatInput);
      const orderTime = parseOrderTime(orderInput);

      if (
        !chatTime ||
        !orderTime ||
        isNaN(chatTime.getTime()) ||
        isNaN(orderTime.getTime())
      ) {
        resultDiv.innerHTML = "⚠ Invalid Date Format";
        resultDiv.style.backgroundColor = "#ff3333";
        resultDiv.style.opacity = "1";
        resultDiv.classList.add("show");
        failedTrialsPanel.classList.remove("show");
        refundSlaPanel.classList.remove("show");
        return;
      }

      const actualDeliveryTime = new Date(
        orderTime.getTime() + deliveryMins * 60 * 1000
      );
      const delay = (chatTime - actualDeliveryTime) / (1000 * 60);

      let status = "",
        color = "";
      let showCompensation = false,
        compensationText = "",
        minutesToCompensation = 0;

      // If no delay (delay < 0), show green status and nothing else
      if (delay < 0) {
        status = "✔ On Time: No delay";
        color = "#00cc00";
        resultDiv.innerHTML = status;
        resultDiv.style.backgroundColor = color;
        resultDiv.style.opacity = "1";
        resultDiv.classList.add("show");
        compPanel.classList.remove("show");
        copyCompBtn.style.display = "none";
        thirdReminderPanel.classList.remove("show");
        rightReminderPanel.classList.remove("show");
        failedTrialsPanel.classList.remove("show");
        refundSlaPanel.classList.remove("show");
        return;
      }

      // New delay logic for all service types
      let delayMsg = "";
      if (delay >= 0 && delay <= 10) {
        delayMsg = "Complaint about short delay";
        color = "#ffd700";
      } else if (delay <= 20) {
        delayMsg = "Complaint about moderate delay";
        color = "#ffb300";
      } else if (delay <= 30) {
        delayMsg = "Complaint about severe delay";
        color = "#ff8c00";
      } else {
        delayMsg = "Complaint about extreme delay";
        color = "#b30000";
      }

      // Compensation logic (unchanged)
      if (selectedType === "tmp") {
        if (selectedOrderType === "fv") {
          showCompensation = delay >= 10;
          compensationText = "TMP FV/tMart Required Compensation (>10 mins)";
        } else if (selectedOrderType === "nfv") {
          showCompensation = delay >= 15;
          compensationText = "TMP NFV Required Compensation (>15 mins)";
        }
        status = `${delayMsg}: ${delay.toFixed(2)} mins delay`;
      } else if (selectedType === "tgo") {
        if (selectedOrderType === "fv") {
          if (delay >= 10) {
            showCompensation = true;
            compensationText = `TGO & Tmart Required Compensation (≥10 mins)`;
          }
        } else if (selectedOrderType === "nfv") {
          if (delay >= 15) {
            showCompensation = true;
            compensationText = `TGO & Tmart Required Compensation (≥15 mins)`;
          }
        }

        status = `${delayMsg}: ${delay.toFixed(2)} mins delay`;
      } else {
        status = `${delayMsg}: ${delay.toFixed(2)} mins delay`;
      }

      resultDiv.innerHTML = status;
      resultDiv.style.backgroundColor = color;
      resultDiv.style.opacity = "1";
      resultDiv.classList.add("show");

      failedTrialsPanel.classList.remove("show");
      refundSlaPanel.classList.remove("show");

      if (showCompensation) {
        document.querySelector(
          "#compensation h3"
        ).innerHTML = `⚠ ${compensationText}`;
        compPanel.classList.add("show");
        copyCompBtn.style.display = "block";
        showCompReasonAnimatedPopup(delay, selectedType);
      } else {
        compPanel.classList.remove("show");
        copyCompBtn.style.display = "none";
        compReasonPopup.classList.remove("show");
      }

      // Trigger third reminder for tgo (≥3 mins and <10 mins before compensation)
      if (
        selectedType === "tmp" ||
        selectedType === "tgo"
      ) {
        let threshold = selectedOrderType === "fv" ? 10 : 15;
        minutesToCompensation = Math.max(0, threshold - delay);
        if (
          minutesToCompensation <= 7 &&
          !showCompensation &&
          minutesToCompensation > 0
        ) {
          startThirdReminder(
            minutesToCompensation,
            selectedType.toUpperCase()
          );
        } else {
          thirdReminderPanel.classList.remove("show");
        }
      } else {
        thirdReminderPanel.classList.remove("show");
      }

      if (selectedType === "tmp") {
        rightReminderPanel.classList.remove("show");
      } else {
        rightReminderPanel.classList.remove("show");
      }
    }

    document
      .querySelectorAll('input[name="compGroup"]')
      .forEach((checkbox) => {
        checkbox.addEventListener("change", function () {
          if (this.checked) {
            document
              .querySelectorAll('input[name="compGroup"]')
              .forEach((cb) => {
                if (cb !== this) cb.checked = false;
              });
          }
          updateCalculateButtonState();
          showTimeCalcServiceMessage();
          // Show FV/NFV selection only for TMP or TGO
          const fvNfvDiv = document.getElementById("fvNfvSelection");
          if (
            this.value === "tmp" ||
            this.value === "tgo"
          ) {
            fvNfvDiv.style.display = "block";
          } else {
            fvNfvDiv.style.display = "none";
            document
              .querySelectorAll('input[name="orderType"]')
              .forEach((r) => (r.checked = false));
          }
        });
      });

    // Add event listeners for order type radio buttons to update button state
    document
      .querySelectorAll('.order-type-selection input[type="radio"]')
      .forEach(function (radio) {
        radio.addEventListener("change", function () {
          updateCalculateButtonState();
        });
      });

    function startCountdown() {
      const orderId = document.getElementById("orderIdInput").value.trim();
      if (!orderId) {
        alert("Please enter an Order ID.");
        return;
      }

      if (activeOrders[orderId]) {
        alert("This Order ID is already being tracked.");
        return;
      }

      const timerContainer = document.getElementById("orderTimers");
      const timerItem = document.createElement("div");
      timerItem.className = "order-timer-item";
      timerItem.id = `timer-${orderId}`;

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "order-timer-checkbox";
      checkbox.id = `checkbox-${orderId}`;
      checkbox.addEventListener("change", function () {
        if (this.checked) {
          timerItem.classList.add("completed");
        } else {
          timerItem.classList.remove("completed");
        }
      });

      const timerContent = document.createElement("div");
      timerContent.className = "order-timer-content";
      timerContent.innerHTML = `Order ${orderId}: <span class="timer-display">10:00</span>`;

      const progressBar = document.createElement("div");
      progressBar.className = "timer-progress";
      const progressBarFill = document.createElement("div");
      progressBarFill.className = "timer-progress-bar";
      progressBarFill.style.width = "100%";
      progressBar.appendChild(progressBarFill);
      timerContent.appendChild(progressBar);

      const timerControls = document.createElement("div");
      timerControls.className = "timer-controls";

      const deleteBtn = document.createElement("button");
      deleteBtn.className = "delete-timer";
      deleteBtn.innerHTML = "❌";
      deleteBtn.title = "Delete timer";
      deleteBtn.addEventListener("click", function () {
        if (activeOrders[orderId]) {
          delete activeOrders[orderId];
          timerContainer.removeChild(timerItem);
        }
      });

      timerControls.appendChild(deleteBtn);
      timerItem.appendChild(checkbox);
      timerItem.appendChild(timerContent);
      timerItem.appendChild(timerControls);
      timerContainer.appendChild(timerItem);

      activeOrders[orderId] = 600;
      const timerDisplay = timerContent.querySelector(".timer-display");
      const totalSeconds = 600;

      const interval = setInterval(() => {
        if (!activeOrders[orderId]) {
          clearInterval(interval);
          return;
        }

        if (activeOrders[orderId] <= 0) {
          clearInterval(interval);
          timerDisplay.innerHTML = "Time's up!";
          timerDisplay.style.color = "red";
          timerDisplay.style.fontWeight = "bold";
          progressBarFill.style.width = "0%";
        } else {
          activeOrders[orderId]--;
          const mins = Math.floor(activeOrders[orderId] / 60)
            .toString()
            .padStart(2, "0");
          const secs = (activeOrders[orderId] % 60)
            .toString()
            .padStart(2, "0");
          timerDisplay.innerHTML = `${mins}:${secs}`;
          progressBarFill.style.width = `${
            (activeOrders[orderId] / totalSeconds) * 100
          }%`;
        }
      }, 1000);

      document.getElementById("orderIdInput").value = "";
    }

    // Dark mode toggle
    const darkModeToggle = document.getElementById("darkModeToggle");
    darkModeToggle.addEventListener("click", function () {
      document.body.classList.toggle("dark-mode");
      if (document.body.classList.contains("dark-mode")) {
        darkModeToggle.innerHTML = "☀️";
      } else {
        darkModeToggle.innerHTML = "🌙";
      }
    });

    // Compensation Reason Animated Popup logic
    const compReasonPopup = document.getElementById(
      "compReasonAnimatedPopup"
    );
    const compReasonPopupText = document.getElementById(
      "compReasonPopupText"
    );
    const closeCompReasonPopup = document.getElementById(
      "closeCompReasonPopup"
    );
    closeCompReasonPopup.addEventListener("click", () => {
      compReasonPopup.classList.remove("show");
    });

    function showCompReasonAnimatedPopup(delay, selectedType) {
      let reason = "";
      let complaint = "";
      // Show for all types if delay > 0
      if (delay <= 0) {
        compReasonPopup.classList.remove("show");
        return;
      }
      if (selectedType == "tmp") {
        if (delay > 0 && delay <= 20) {
          reason = "Restaurant Late Order - TMP";
          complaint = "Complaint about moderate delay";
        } else if (delay > 20 && delay <= 29) {
          reason = "Restaurant Late Order - TMP";
          complaint = "Complaint about severe delay";
        } else if (delay >= 30) {
          reason = "Restaurant Late Order - TMP";
          complaint = "Complaint about extreme delay";
        }
      } else {
        if (delay > 0 && delay <= 20) {
          reason = "Moderate Delay";
          complaint = "Complaint about moderate delay";
        } else if (delay >= 21 && delay <= 30) {
          reason = "Severe Delay";
          complaint = "Complaint about severe delay";
        } else if (delay > 30) {
          reason = "Extreme Delay";
          complaint = "Complaint about extreme delay";
        }
      }

      if (reason) {
        compReasonPopupText.textContent = reason;
        compReasonPopup.classList.add("show");
      }
    }

    // Contact Driver Popup logic
    const contactDriverBtn = document.getElementById("contactDriverBtn");
    const contactDriverPopup = document.getElementById("contactDriverPopup");
    const closeContactDriverPopup = document.getElementById(
      "closeContactDriverPopup"
    );
    contactDriverBtn.addEventListener("click", () => {
      contactDriverPopup.classList.add("show");
    });
    closeContactDriverPopup.addEventListener("click", () => {
      contactDriverPopup.classList.remove("show");
    });

    // SMS CST Popup logic
    const smsCstBtn = document.getElementById("smsCstBtn");
    const smsCstPopup = document.getElementById("smsCstPopup");
    const closeSmsCstPopup = document.getElementById("closeSmsCstPopup");
    smsCstBtn.addEventListener("click", () => {
      smsCstPopup.classList.add("show");
    });
    closeSmsCstPopup.addEventListener("click", () => {
      smsCstPopup.classList.remove("show");
    });

    // Show/hide FABs based on service selection
    function updateFabBtnsVisibility() {
      const serviceSelected = document.querySelector(
        'input[name="compGroup"]:checked'
      );
      const fabBtns = document.getElementById("fabBtnsBottomRight");
      if (serviceSelected) {
        fabBtns.classList.add("show");
      } else {
        fabBtns.classList.remove("show");
      }
    }
    document
      .querySelectorAll('input[name="compGroup"]')
      .forEach((checkbox) => {
        checkbox.addEventListener("change", updateFabBtnsVisibility);
      });
    updateFabBtnsVisibility();

    // Floating button to toggle time calculator
    const toggleTimeCalcBtn = document.getElementById("toggleTimeCalcBtn");
    const timeCalculator = document.getElementById("timeCalculator");
    let timeCalcVisible = true;
    function updateTimeCalcBtnLabel() {
      if (timeCalculator.style.display === "none") {
        toggleTimeCalcBtn.title = "Show Time Calculator";
        toggleTimeCalcBtn.innerHTML = "🕒";
      } else {
        toggleTimeCalcBtn.title = "Hide Time Calculator";
        toggleTimeCalcBtn.innerHTML = "🕒";
      }
    }
    toggleTimeCalcBtn.addEventListener("click", function () {
      if (timeCalculator.style.display === "none") {
        timeCalculator.style.display = "";
      } else {
        timeCalculator.style.display = "none";
      }
      updateTimeCalcBtnLabel();
    });
    // Initialize label
    updateTimeCalcBtnLabel();

    // Floating button to toggle failedTrials
    const toggleFailedTrialsBtn = document.getElementById(
      "toggleFailedTrialsBtn"
    );
    const failedTrials = document.getElementById("failedTrials");
    function updateFailedTrialsBtnLabel() {
      if (failedTrials.style.display === "none") {
        toggleFailedTrialsBtn.title = "Show Failed Trials";
        toggleFailedTrialsBtn.innerHTML = "⚠️";
      } else {
        toggleFailedTrialsBtn.title = "Hide Failed Trials";
        toggleFailedTrialsBtn.innerHTML = "⚠️";
      }
    }
    toggleFailedTrialsBtn.addEventListener("click", function () {
      if (failedTrials.style.display === "none") {
        failedTrials.style.display = "";
      } else {
        failedTrials.style.display = "none";
      }
      updateFailedTrialsBtnLabel();
    });
    // Initialize label
    updateFailedTrialsBtnLabel();

    // Floating button to toggle refundSlaPanel
    const toggleRefundSlaBtn = document.getElementById("toggleRefundSlaBtn");
    const refundSlaPanel = document.getElementById("refundSlaPanel");
    function updateRefundSlaBtnLabel() {
      if (refundSlaPanel.style.display === "none") {
        toggleRefundSlaBtn.title = "Show Refund SLA";
        toggleRefundSlaBtn.innerHTML = "🧾";
      } else {
        toggleRefundSlaBtn.title = "Hide Refund SLA";
        toggleRefundSlaBtn.innerHTML = "🧾";
      }
    }
    toggleRefundSlaBtn.addEventListener("click", function () {
      if (refundSlaPanel.style.display === "none") {
        refundSlaPanel.style.display = "";
      } else {
        refundSlaPanel.style.display = "none";
      }
      updateRefundSlaBtnLabel();
    });
    // Initialize label
    updateRefundSlaBtnLabel();
</script>
<!-- tool 1 logic -->

<!-- tool 2 logic -->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const parseButton = document.getElementById('parse-button');
        const inputData = document.getElementById('input-data');
        const additionalInputData = document.getElementById('additional-input-data');
        const currentTimeInput = document.getElementById('current-time-input');
        const estDropoffInput = document.getElementById('est-dropoff-input');
        const deliveryTimeInput = document.getElementById('delivery-time-input');
        const resultContainer = document.getElementById('result-container');
        const resultBody = document.getElementById('result-body');
        const dispatchTimeDiv = document.getElementById('dispatch-time');
        const waitingTimeDiv = document.getElementById('waiting-time');
        const deliveryTimeDiv = document.getElementById('delivery-time');
        const riderDelayDiv = document.getElementById('rider-delay');
        const pickUpdatedVarianceDiv = document.getElementById('pick-updated-variance');
        const riderDelayDropoffDiv = document.getElementById('rider-delay-dropoff');
        const riderStatusGroup = document.getElementById('rider-status-group');
        const orderTypeGroup = document.getElementById('order-type-group');
        const additionalTimelineContainer = document.getElementById('additional-timeline-container');
        const additionalTimelineBody = document.getElementById('additional-timeline-body');
        const darkModeBtn = document.getElementById('dark-mode-toggle');
        const fabGenerate = document.getElementById('fab-generate');
        const resetBtn = document.getElementById('reset-btn');
        const exampleMainBtn = document.getElementById('example-main-btn');
        const clearMainBtn = document.getElementById('clear-main-btn');
        const exampleAdditionalBtn = document.getElementById('example-additional-btn');
        const clearAdditionalBtn = document.getElementById('clear-additional-btn');
        const helpModalBtn = document.getElementById('help-modal-btn');
        const helpModalBtnFooter = document.getElementById('help-modal-btn-footer');
        const helpModalClose = document.getElementById('help-modal-close');
        const spinnerOverlay = document.getElementById('spinner-overlay');
        const scheduledTimeDiv = document.getElementById('scheduled-time');
        const delayRiderRedispatchedDiv = document.getElementById('delay-rider-redispatched');
        const unprofessionalBtn = document.getElementById('unprofessional-btn');

        let selectedRiderStatus = null;
        let selectedOrderType = null;
        let unprofessionalOverride = false;

        darkModeBtn.addEventListener('click', function() {
            document.body.classList.toggle('dark-mode');
            if (document.body.classList.contains('dark-mode')) {
                darkModeBtn.innerHTML = '<i class="fas fa-sun"></i> <span>Light Mode</span>';
            } else {
                darkModeBtn.innerHTML = '<i class="fas fa-moon"></i> <span>Dark Mode</span>';
            }
        });

        function openHelpModal() {
            document.getElementById('help-modal').style.display = 'flex';
        }
        function closeHelpModal() {
            document.getElementById('help-modal').style.display = 'none';
        }
        helpModalBtn.onclick = openHelpModal;
        helpModalBtnFooter.onclick = openHelpModal;
        helpModalClose.onclick = closeHelpModal;
        window.onclick = function(event) {
            if (event.target === document.getElementById('help-modal')) closeHelpModal();
        };

        exampleMainBtn.onclick = function() {
            inputData.value = '1:59 AM **Scheduled**\n4:07 AM **Queued**\n4:07 AM **Dispatched**\n4:07 AM **Courier Notified**\n4:08 AM **Accepted**\n4:27 AM **Queued**\n4:27 AM **Dispatched**\n4:27 AM **Courier Notified**\n4:27 AM **Accepted**\n4:40 AM **Near Pickup**';
        };
        clearMainBtn.onclick = function() {
            inputData.value = '';
        };
        exampleAdditionalBtn.onclick = function() {
            additionalInputData.value = 'Ordered at 1:50 AM\nSend to restaurant 1:51 AM\nPickup - Committed 2:15 AM\nPickup - Updated 2:17 AM\nPicked up at 2:18 AM\nEst. Dropoff Arrival 3:00 AM';
        };
        clearAdditionalBtn.onclick = function() {
            additionalInputData.value = '';
        };

        resetBtn.onclick = function() {
            inputData.value = '';
            additionalInputData.value = '';
            currentTimeInput.value = '';
            deliveryTimeInput.value = '';
            document.querySelectorAll('.status-button').forEach(btn => btn.classList.remove('selected'));
            selectedRiderStatus = null;
            selectedOrderType = null;
            resultContainer.classList.remove('visible');
            additionalTimelineContainer.classList.remove('visible');
            unprofessionalOverride = false;
            updateCancellationReason();
        };

        fabGenerate.onclick = function() {
            parseButton.click();
        };

        function showSpinner() {
            spinnerOverlay.style.display = 'flex';
        }
        function hideSpinner() {
            spinnerOverlay.style.display = 'none';
        }

        riderStatusGroup.querySelectorAll('.status-button').forEach(button => {
            button.addEventListener('click', function() {
                riderStatusGroup.querySelectorAll('.status-button').forEach(btn => btn.classList.remove('selected'));
                this.classList.add('selected');
                selectedRiderStatus = this.getAttribute('data-status');
            });
        });

        orderTypeGroup.querySelectorAll('.status-button').forEach(button => {
            button.addEventListener('click', function() {
                orderTypeGroup.querySelectorAll('.status-button').forEach(btn => btn.classList.remove('selected'));
                this.classList.add('selected');
                selectedOrderType = this.getAttribute('data-type');
            });
        });

        parseButton.addEventListener('click', function() {
            showSpinner();
            const originalBtnText = parseButton.innerHTML;
            parseButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
            parseButton.disabled = true;

            setTimeout(() => {
                try {
                    const mainData = inputData.value.trim();
                    const additionalData = additionalInputData.value.trim();
                    const deliveryTime = deliveryTimeInput.value.trim();

                    if (!mainData && !additionalData) {
                        showToast('Please paste some data in at least one of the text areas.');
                        resetButton();
                        hideSpinner();
                        return;
                    }

                    if (!selectedRiderStatus) {
                        showToast('Please select a Rider Status (Reachable or Unreachable).');
                        resetButton();
                        hideSpinner();
                        return;
                    }

                    const currentTime = currentTimeInput.value.trim();
                    if (!currentTime) {
                        showToast('Please enter the Current Time.');
                        resetButton();
                        hideSpinner();
                        return;
                    }

                    if (!deliveryTime) {
                        showToast('Please enter the Delivery Time.');
                        resetButton();
                        hideSpinner();
                        return;
                    }

                    if (!selectedOrderType) {
                        showToast('Please select an Order Type (Normal Order or NFV).');
                        resetButton();
                        hideSpinner();
                        return;
                    }

                    let timelineData = [];
                    let estDropoffArrivalTime = null;
                    let estPickupArrivalTime = null;
                    if (mainData) {
                        const result = parseMainTimelineData(mainData);
                        timelineData = result.parsedData;
                        estDropoffArrivalTime = result.estDropoffArrivalTime;
                        estPickupArrivalTime = result.estPickupArrivalTime;
                    }

                    let additionalTimelineData = [];
                    if (additionalData) {
                        additionalTimelineData = parseAdditionalTimelineData(additionalData);
                    }

                    displayResults(timelineData, additionalTimelineData, deliveryTime, currentTime, estDropoffArrivalTime, estPickupArrivalTime);

                    if (resultContainer.classList.contains('visible')) {
                        setTimeout(() => {
                            resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }, 100);
                    }
                } catch (error) {
                    showToast('An error occurred while processing the data. Please check your input format.');
                    console.error(error);
                } finally {
                    resetButton();
                    hideSpinner();
                }

                function resetButton() {
                    parseButton.innerHTML = originalBtnText;
                    parseButton.disabled = false;
                }
            }, 500);
        });

        function showToast(message) {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.position = 'fixed';
            toast.style.bottom = '20px';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            toast.style.backgroundColor = '#333';
            toast.style.color = 'white';
            toast.style.padding = '12px 20px';
            toast.style.borderRadius = '8px';
            toast.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
            toast.style.zIndex = '3000';
            toast.style.opacity = '0';
            toast.style.transition = 'opacity 0.3s, transform 0.3s';

            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '1';
                toast.style.transform = 'translateX(-50%) translateY(0)';
            }, 10);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) translateY(10px)';
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }

        function parseMainTimelineData(text) {
            const lines = text.split('\n');
            const parsedData = [];
            const timePattern = /(\d+:\d+\s*[AP]M)/i;
            const eventPattern = /\*\*(.*?)\*\*/;
            const knownEvents = [
                'Scheduled', 'Queued', 'Dispatched', 'Courier Notified', 'Accepted',
                'Cancelled', 'Auto Dispatching', 'Manual Undispatch',
                'Picked Up', 'Picked Up Updated', 'Near Pickup', 'Delivered', 'Left Pickup',
                'Near Dropoff', 'Completed'
            ];

            let currentTime = null;
            let lastFoundIndex = -1;
            let estDropoffArrivalTime = null;
            let estPickupArrivalTime = null;

            // First, try to extract estimated times from the raw text
            // Note: This is disabled for table format to avoid conflicts
            let isTableFormat = lines[0].includes('TIME') && lines[0].includes('EVENT');
            if (!isTableFormat) {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    // Look for lines containing dropoff arrival times
                    const dropoffMatch = line.match(/(\d{1,2}:\d{2}\s*[AP]M)/g);
                    if (dropoffMatch && dropoffMatch.length > 0) {
                        // Check if this line contains dropoff-related information
                        if (line.toLowerCase().includes('dropoff') || 
                            line.includes('01:42') || line.includes('01:49') ||
                            line.includes('02:42') || line.includes('02:49') ||
                            line.includes('03:42') || line.includes('03:49')) {
                            // Take the last time in the line as it's likely the dropoff arrival
                            estDropoffArrivalTime = dropoffMatch[dropoffMatch.length - 1];
                        }
                        // Check if this line contains pickup arrival information (from Accepted event)
                        if (line.toLowerCase().includes('accepted') && dropoffMatch.length >= 3) {
                            // The second time in the line is usually the estimated pickup arrival
                            estPickupArrivalTime = dropoffMatch[1]; // Index 1 for pickup arrival
                        }
                    }
                }
            }

            if (isTableFormat) {
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const cells = line.split(/\t|\s{2,}|\|/).map(cell => cell.trim()).filter(cell => cell !== '');
                    if (cells.length < 2) continue;
                    
                    // Check if the event cell contains "Manual Undispatch"
                    let eventName = cells[1];
                    if (cells[1].toLowerCase().includes('manual undispatch')) {
                        eventName = 'Manual Undispatch';
                    }
                    
                    // Extract estimated dropoff departure time from the last column if it exists
                    let estDropoffDeparture = null;
                    if (cells.length >= 8) { // Assuming Est.dropoff departure is the last column
                        const lastCell = cells[cells.length - 1];
                        const timeMatch = lastCell.match(/(\d{1,2}:\d{2}\s*[AP]M)/i);
                        if (timeMatch) {
                            estDropoffDeparture = timeMatch[1];
                            console.log(`Extracted dropoff departure for ${eventName}: ${estDropoffDeparture} from cell: "${lastCell}"`);
                        }
                    }
                    

                    
                    // Debug: Show all cells for this row
                    console.log(`Row ${i}: Time=${cells[0]}, Event=${eventName}, All cells:`, cells);
                    
                    const lastEntry = parsedData[parsedData.length - 1];
                    if (!lastEntry || lastEntry.time !== cells[0] || lastEntry.event !== eventName) {
                        parsedData.push({
                            time: cells[0],
                            event: eventName,
                            estDropoffDeparture: estDropoffDeparture
                        });
                    }
                }
            } else {
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const timeMatch = line.match(timePattern);
                    if (timeMatch) {
                        currentTime = timeMatch[1].trim();
                        lastFoundIndex = i;
                        const timeEndPos = line.indexOf(currentTime) + currentTime.length;
                        const restOfLine = line.substring(timeEndPos).trim();
                        const eventMatch = line.match(eventPattern);

                        let eventName = null;
                        if (eventMatch) {
                            eventName = eventMatch[1].trim();
                        } else {
                            for (const event of knownEvents) {
                                if (restOfLine.toLowerCase().includes(event.toLowerCase())) {
                                    eventName = event;
                                    break;
                                }
                            }
                            if (!eventName && i + 1 < lines.length) {
                                const nextLine = lines[i + 1].trim();
                                if (!nextLine.match(timePattern)) {
                                    const nextEventMatch = nextLine.match(eventPattern);
                                    if (nextEventMatch) {
                                        eventName = nextEventMatch[1].trim();
                                    } else {
                                        for (const event of knownEvents) {
                                            if (nextLine.toLowerCase().includes(event.toLowerCase())) {
                                                eventName = event;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        if (eventName && knownEvents.includes(eventName)) {
                            const lastEntry = parsedData[parsedData.length - 1];
                            if (!lastEntry || lastEntry.time !== currentTime || lastEntry.event !== eventName) {
                                parsedData.push({
                                    time: currentTime,
                                    event: eventName
                                });
                            }
                        }
                    } else if (i === lastFoundIndex + 1 && currentTime) {
                        const eventMatch = line.match(eventPattern);
                        let eventName = null;
                        if (eventMatch) {
                            eventName = eventMatch[1].trim();
                        } else {
                            for (const event of knownEvents) {
                                if (line.toLowerCase().includes(event.toLowerCase())) {
                                    eventName = event;
                                    break;
                                }
                            }
                        }
                        if (eventName && knownEvents.includes(eventName)) {
                            const lastEntry = parsedData[parsedData.length - 1];
                            if (!lastEntry || lastEntry.time !== currentTime || lastEntry.event !== eventName) {
                                parsedData.push({
                                    time: currentTime,
                                    event: eventName
                                });
                            }
                        }
                    }
                }

                if (parsedData.length === 0) {
                    currentTime = null;
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;

                        const timeMatch = line.match(timePattern);
                        if (timeMatch) {
                            currentTime = timeMatch[1].trim();
                            for (let j = i + 1; j < lines.length; j++) {
                                const nextLine = lines[j].trim();
                                if (!nextLine) continue;
                                if (nextLine.match(timePattern)) break;
                                let foundEvent = false;
                                for (const event of knownEvents) {
                                    if (nextLine.toLowerCase().includes(event.toLowerCase())) {
                                        const lastEntry = parsedData[parsedData.length - 1];
                                        if (!lastEntry || lastEntry.time !== currentTime || lastEntry.event !== event) {
                                            parsedData.push({
                                                time: currentTime,
                                                event: event
                                            });
                                        }
                                        foundEvent = true;
                                        break;
                                    }
                                }
                                if (foundEvent) break;
                            }
                        }
                    }
                }
            }

            return { parsedData, estDropoffArrivalTime, estPickupArrivalTime };
        }

        function parseAdditionalTimelineData(text) {
            const lines = text.split('\n').map(line => line.trim()).filter(line => line);
            const parsedData = [];
            const timePattern = /(\d+:\d+(?::\d+)?\s*(?:[AP]M|am|pm))/i;
            const dateTimePattern = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s+\d+\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i;
            const knownEvents = [
                'Ordered at', 'Send to restaurant', 'Restaurant confirmed at',
                'Pickup - Committed', 'Pickup - Updated', 'Food is ready at',
                'Picked up at', 'Est. Dropoff Arrival'
            ];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (dateTimePattern.test(line) && !timePattern.test(line)) continue;

                const timeMatch = line.match(timePattern);
                let eventName = null;
                let timeStr = null;

                if (timeMatch) {
                    timeStr = timeMatch[0];
                    const timeIndex = line.indexOf(timeStr);
                    const beforeTime = line.substring(0, timeIndex).trim();
                    const afterTime = line.substring(timeIndex + timeStr.length).trim();

                    for (const event of knownEvents) {
                        if (line.toLowerCase().includes(event.toLowerCase())) {
                            eventName = event;
                            break;
                        }
                    }

                    if (!eventName) {
                        if (beforeTime) {
                            eventName = knownEvents.find(event => beforeTime.toLowerCase().includes(event.toLowerCase())) || beforeTime;
                        } else if (afterTime) {
                            eventName = knownEvents.find(event => afterTime.toLowerCase().includes(event.toLowerCase())) || afterTime;
                        } else if (i > 0 && !lines[i - 1].match(timePattern)) {
                            eventName = lines[i - 1];
                        } else if (i + 1 < lines.length && !lines[i + 1].match(timePattern)) {
                            eventName = lines[i + 1];
                            i++;
                        }
                    }

                    if (eventName && !knownEvents.includes(eventName)) {
                        eventName = knownEvents.find(event => eventName.toLowerCase().includes(event.toLowerCase())) || eventName;
                    }
                }

                if (eventName && timeStr && knownEvents.includes(eventName)) {
                    const formattedTime = standardizeTimeFormat(timeStr);
                    if (!parsedData.some(item => item.event === eventName && item.time === formattedTime)) {
                        parsedData.push({
                            event: eventName,
                            time: formattedTime
                        });
                    }
                }
            }

            const orderedAtIndex = parsedData.findIndex(item => item.event === 'Ordered at');
            const sendToRestaurantIndex = parsedData.findIndex(item => item.event === 'Send to restaurant');
            if (sendToRestaurantIndex !== -1 && orderedAtIndex === -1) {
                parsedData.splice(sendToRestaurantIndex, 0, {
                    event: 'Ordered at',
                    time: standardizeTimeFormat(parsedData[sendToRestaurantIndex].time)
                });
            }

            return parsedData;
        }

        function standardizeTimeFormat(timeStr) {
            // Support both 12-hour and 24-hour time formats
            const dateTimePattern = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s+\d+\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d+:\d+(?::\d+)?\s*(?:am|pm))/i;
            const dateMatch = timeStr.match(dateTimePattern);
            if (dateMatch) timeStr = dateMatch[1];

            // First check if it's a 12-hour format with AM/PM
            const twelveHourPattern = /^(\d{1,2}):(\d{2})(?::(\d{2}))?\s*([AP]M|am|pm)$/i;
            const twelveHourMatch = timeStr.match(twelveHourPattern);
            if (twelveHourMatch) {
                let hours = parseInt(twelveHourMatch[1], 10);
                let minutes = parseInt(twelveHourMatch[2], 10);
                let seconds = twelveHourMatch[3] ? parseInt(twelveHourMatch[3], 10) : undefined;
                let period = twelveHourMatch[4].toUpperCase();
                
                // Convert to 12-hour display format
                if (hours === 0) hours = 12;
                else if (hours > 12) hours = hours % 12 || 12;
                
                hours = hours.toString().padStart(2, '0');
                minutes = minutes.toString().padStart(2, '0');
                
                if (seconds !== undefined && !isNaN(seconds)) {
                    seconds = seconds.toString().padStart(2, '0');
                    return `${hours}:${minutes}:${seconds} ${period}`;
                }
                return `${hours}:${minutes} ${period}`;
            }

            // Check for 24-hour format (e.g., 13:44 or 23:59:59) - no AM/PM
            let match24 = timeStr.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
            if (match24) {
                let hours = parseInt(match24[1], 10);
                let minutes = parseInt(match24[2], 10);
                let seconds = match24[3] ? parseInt(match24[3], 10) : undefined;
                let period = hours >= 12 ? 'PM' : 'AM';
                let displayHours = hours % 12;
                if (displayHours === 0) displayHours = 12;
                displayHours = displayHours.toString().padStart(2, '0');
                minutes = minutes.toString().padStart(2, '0');
                if (seconds !== undefined && !isNaN(seconds)) {
                    seconds = seconds.toString().padStart(2, '0');
                    return `${displayHours}:${minutes}:${seconds} ${period}`;
                }
                return `${displayHours}:${minutes} ${period}`;
            }

            // Fallback: try to parse as 12-hour format without explicit AM/PM
            let [time, period = ''] = timeStr.split(/(?=[AP]M|am|pm)/i).map(s => s.trim());
            let [hours, minutes, seconds] = time.split(':').map(Number);

            if (isNaN(hours) || isNaN(minutes)) return timeStr;

            if (hours === 0) hours = 12;
            else if (hours > 12) hours = hours % 12 || 12;

            hours = hours.toString().padStart(2, '0');
            minutes = minutes.toString().padStart(2, '0');
            period = period.toUpperCase() || (hours >= 12 ? 'PM' : 'AM');

            if (seconds !== undefined && !isNaN(seconds)) {
                seconds = seconds.toString().padStart(2, '0');
                return `${hours}:${minutes}:${seconds} ${period}`;
            }
            return `${hours}:${minutes} ${period}`;
        }

        function parseCurrentTimeFormat(timeStr) {
            // Parse format like "24.07.2025, 08:49 AM"
            const match = timeStr.match(/(\d{1,2})\.(\d{1,2})\.(\d{4}),\s*(\d{1,2}):(\d{2})\s*([AP]M)/i);
            if (match) {
                const day = parseInt(match[1], 10);
                const month = parseInt(match[2], 10);
                const year = parseInt(match[3], 10);
                let hours = parseInt(match[4], 10);
                const minutes = parseInt(match[5], 10);
                const period = match[6].toUpperCase();
                
                // Convert to 24-hour format for calculation
                if (period === 'PM' && hours !== 12) {
                    hours += 12;
                } else if (period === 'AM' && hours === 12) {
                    hours = 0;
                }
                
                // Return time in standard format for timeToMinutes function
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }
            return null;
        }

        function timeToMinutes(timeStr) {
            // Support both 12-hour and 24-hour time formats
            let match24 = timeStr.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
            if (match24) {
                let hours = parseInt(match24[1], 10);
                let minutes = parseInt(match24[2], 10);
                let seconds = match24[3] ? parseInt(match24[3], 10) : 0;
                return hours * 60 + minutes + (seconds / 60);
            }
            const [time, period = ''] = timeStr.split(/(?=[AP]M|am|pm)/i).map(s => s.trim());
            const timeParts = time.split(':').map(Number);
            let hours = timeParts[0] || 0;
            let minutes = timeParts[1] || 0;
            let seconds = timeParts[2] || 0;

            let totalMinutes = hours * 60 + minutes + (seconds / 60);
            if (period.toUpperCase().includes('PM') && hours !== 12) {
                totalMinutes += 12 * 60;
            } else if (period.toUpperCase().includes('AM') && hours === 12) {
                totalMinutes = minutes + (seconds / 60);
            }
            return totalMinutes;
        }

        function formatTimeDifference(minutes) {
            if (minutes < 0) minutes = 0;
            const hours = Math.floor(minutes / 60);
            const mins = Math.round(minutes % 60);
            let displayText = '';
            if (hours > 0) displayText += `${hours} hour${hours !== 1 ? 's' : ''} `;
            displayText += `${mins} minute${mins !== 1 ? 's' : ''}`;
            return displayText;
        }

        function normalizeEventName(event) {
            return event.toLowerCase().replace(/[\s-]/g, '');
        }

        function displayResults(mainData, additionalData, deliveryTime, currentTime, estDropoffArrivalTime, estPickupArrivalTime) {
            let pickUpCommittedTime = null;
            let pickUpCommittedIndex = -1;
            let firstNearPickupTime = null;
            let finalDispatchTime = 0;
            let nfvDelay = 0; // Declare at function level for NFV delay calculation
            resultBody.innerHTML = '';
            additionalTimelineBody.innerHTML = '';
            dispatchTimeDiv.textContent = '--';
            waitingTimeDiv.textContent = '--';
            deliveryTimeDiv.textContent = deliveryTime ? `${deliveryTime} minutes` : '--';
            riderDelayDiv.textContent = '--';
            pickUpdatedVarianceDiv.textContent = '--';
            riderDelayDropoffDiv.textContent = '--';
            scheduledTimeDiv.textContent = '--';
            delayRiderRedispatchedDiv.textContent = '--';

            let pickedUpAtTime = null;
            // First try to find "Picked up at" in additional timeline
            for (const item of additionalData) {
                if (normalizeEventName(item.event) === 'pickedupat') {
                    pickedUpAtTime = item.time;
                    break;
                }
            }
            
            // If not found in additional timeline, try to find "Picked up" in main timeline
            if (!pickedUpAtTime) {
                for (const item of mainData) {
                    if (item.event.toLowerCase().includes('picked up')) {
                        pickedUpAtTime = item.time;
                        break;
                    }
                }
            }

            if (mainData.length > 0) {
                mainData.forEach(item => {
                    const row = document.createElement('tr');
                    const timeCell = document.createElement('td');
                    timeCell.className = 'timestamp';
                    timeCell.textContent = item.time;
                    const eventCell = document.createElement('td');
                    const eventLower = item.event.toLowerCase();
                    let eventClass = 'event';
                    if (eventLower.includes('dispatch')) eventClass += ' event-dispatched';
                    else if (eventLower.includes('queue')) eventClass += ' event-queued';
                    else if (eventLower.includes('notif')) eventClass += ' event-notified';
                    else if (eventLower.includes('accept')) eventClass += ' event-accepted';
                    else if (eventLower.includes('cancel')) eventClass += ' event-cancelled';
                    else if (eventLower.includes('picked up')) eventClass += ' event-picked-up';
                    else if (eventLower.includes('near pickup')) eventClass += ' event-near-pickup';
                    else if (eventLower.includes('left pickup')) eventClass += ' event-left-pickup';
                    else if (eventLower.includes('near dropoff')) eventClass += ' event-near-dropoff';
                    else if (eventLower.includes('completed')) eventClass += ' event-completed';
                    else if (eventLower.includes('scheduled')) eventClass += ' event-scheduled';
                    eventCell.className = eventClass;
                    eventCell.textContent = item.event;
                    row.appendChild(timeCell);
                    row.appendChild(eventCell);
                    resultBody.appendChild(row);
                });

                // Calculate total dispatch time from Queued to Accepted only
                console.log('=== DISPATCH TIME CALCULATION ===');
                let allDispatchPeriods = [];
                let dispatchQueuedEvents = [];
                let dispatchAcceptedEvents = [];
                
                // Collect all Queued and Accepted events
                for (const item of mainData) {
                    if (item.event.toLowerCase().includes('queue')) {
                        dispatchQueuedEvents.push({
                            time: item.time,
                            minutes: timeToMinutes(item.time)
                        });
                        console.log(`Processing Queued event: ${item.time} (${timeToMinutes(item.time)} minutes)`);
                    }
                    if (item.event.toLowerCase().includes('accepted')) {
                        dispatchAcceptedEvents.push({
                            time: item.time,
                            minutes: timeToMinutes(item.time)
                        });
                    }
                }
                
                // Sort events by time
                dispatchQueuedEvents.sort((a, b) => a.minutes - b.minutes);
                dispatchAcceptedEvents.sort((a, b) => a.minutes - b.minutes);
                
                // For each Queued event, find the next chronological Accepted event
                for (let i = 0; i < dispatchQueuedEvents.length; i++) {
                    const queuedEvent = dispatchQueuedEvents[i];
                    console.log(`Looking for Accepted event after ${queuedEvent.time}`);
                    
                    // Find the next Accepted event that occurs after this Queued event
                    let matchingAccepted = null;
                    for (const acceptedEvent of dispatchAcceptedEvents) {
                        if (acceptedEvent.minutes >= queuedEvent.minutes) {
                            // Found an Accepted event that occurs at or after the Queued event
                            matchingAccepted = acceptedEvent;
                            break;
                        }
                    }
                    
                    if (matchingAccepted) {
                        let timeDifference = matchingAccepted.minutes - queuedEvent.minutes;
                        if (timeDifference < 0) timeDifference += 1440; // Handle overnight cases
                        
                        allDispatchPeriods.push({
                            start: queuedEvent.minutes,
                            end: matchingAccepted.minutes,
                            duration: timeDifference,
                            startTime: queuedEvent.time,
                            endTime: matchingAccepted.time
                        });
                        
                        console.log(`Found dispatch period: ${queuedEvent.time} to ${matchingAccepted.time} = ${timeDifference} minutes`);
                    }
                }
                
                // For dispatch time, use the longest individual period
                allDispatchPeriods.sort((a, b) => b.duration - a.duration);
                
                if (allDispatchPeriods.length > 0) {
                    const longestPeriod = allDispatchPeriods[0];
                    finalDispatchTime = longestPeriod.duration;
                    console.log(`Using longest dispatch period: ${longestPeriod.startTime} to ${longestPeriod.endTime} = ${longestPeriod.duration} minutes`);
                }
                
                console.log(`Total dispatch time calculated: ${finalDispatchTime} minutes`);
                
                if (finalDispatchTime > 0) {
                    dispatchTimeDiv.textContent = formatTimeDifference(finalDispatchTime);
                } else {
                    dispatchTimeDiv.textContent = 'Not available';
                }


                for (let i = 0; i < additionalData.length; i++) {
                    if (normalizeEventName(additionalData[i].event) === 'pickupcommitted') {
                        pickUpCommittedTime = additionalData[i].time;
                        pickUpCommittedIndex = i;
                        break;
                    }
                }

                // Find Near Pickup time from main timeline
                for (let i = 0; i < mainData.length; i++) {
                    if (!firstNearPickupTime && mainData[i].event.toLowerCase().includes('near pickup')) {
                        firstNearPickupTime = mainData[i].time;
                        break;
                    }
                }


                let riderDelayTime = 0;
                let pickUpUpdatedTime = null;
                for (const item of additionalData) {
                    if (normalizeEventName(item.event) === 'pickupupdated') {
                        pickUpUpdatedTime = item.time;
                        break;
                    }
                }

                if (firstNearPickupTime && (pickUpCommittedTime || pickUpUpdatedTime)) {
                    const nearPickupMinutes = timeToMinutes(firstNearPickupTime);
                    const committedMinutes = pickUpCommittedTime ? timeToMinutes(pickUpCommittedTime) : Infinity;
                    const updatedMinutes = pickUpUpdatedTime ? timeToMinutes(pickUpUpdatedTime) : Infinity;
                    
                    console.log('=== RIDER DELAY CALCULATION ===');
                    console.log('Near Pickup time:', firstNearPickupTime, '=', nearPickupMinutes, 'minutes');
                    console.log('Pickup - Committed time:', pickUpCommittedTime, '=', committedMinutes, 'minutes');
                    console.log('Pickup - Updated time:', pickUpUpdatedTime, '=', updatedMinutes, 'minutes');
                    
                    // If Near Pickup is before either Pickup - Committed or Pickup - Updated, set delay to 0
                    if (nearPickupMinutes <= committedMinutes || nearPickupMinutes <= updatedMinutes) {
                        riderDelayTime = 0;
                        console.log('Near Pickup is before or at committed/updated time, setting delay to 0');
                    } else {
                        // Use the later of Committed or Updated time for delay calculation
                        const referenceMinutes = Math.max(committedMinutes, updatedMinutes);
                        let delay = nearPickupMinutes - referenceMinutes;
                        if (delay < 0) delay += 1440;
                        riderDelayTime = delay;
                        console.log('Calculated rider delay:', delay, 'minutes');
                    }
                }

                // If no Near Pickup event but we have current time, calculate delay from Accepted to current time
                if (!firstNearPickupTime && currentTime) {
                    const parsedCurrentTime = parseCurrentTimeFormat(currentTime);
                    if (parsedCurrentTime) {
                        const currentMinutes = timeToMinutes(parsedCurrentTime);
                        
                        // Find the last Accepted event time
                        let acceptedTime = null;
                        for (let i = mainData.length - 1; i >= 0; i--) {
                            const item = mainData[i];
                            if (item.event.toLowerCase().includes('accepted')) {
                                acceptedTime = item.time;
                                break;
                            }
                        }
                        
                        if (acceptedTime) {
                            const acceptedMinutes = timeToMinutes(acceptedTime);
                            riderDelayTime = currentMinutes - acceptedMinutes;
                            // If current time is before accepted time, there's no delay yet
                            if (riderDelayTime < 0) {
                                riderDelayTime = 0;
                                console.log(`Current time (${currentTime}) is before Accepted time (${acceptedTime}), setting rider delay to 0`);
                            }
                        }
                    }
                }
                
                if (firstNearPickupTime || riderDelayTime > 0) {
                    riderDelayDiv.textContent = formatTimeDifference(riderDelayTime);
                } else {
                    riderDelayDiv.textContent = 'Not available';
                }

                // Calculate Delay rider - redispatched: Sum of all durations between Accepted and Queued events
                let totalRedispatchedDelay = 0;
                let acceptedEvents = [];
                let queuedEvents = [];
                
                // Collect all Accepted and Queued events with their times
                for (const item of mainData) {
                    if (item.event.toLowerCase().includes('accepted')) {
                        acceptedEvents.push({
                            time: item.time,
                            minutes: timeToMinutes(item.time),
                            event: item.event
                        });
                    } else if (item.event.toLowerCase().includes('queued')) {
                        queuedEvents.push({
                            time: item.time,
                            minutes: timeToMinutes(item.time),
                            event: item.event
                        });
                    }
                }
                
                // Sort events by time
                acceptedEvents.sort((a, b) => a.minutes - b.minutes);
                queuedEvents.sort((a, b) => a.minutes - b.minutes);
                
                // Calculate all delays between Accepted events and subsequent Queued events
                if (acceptedEvents.length > 0 && queuedEvents.length > 0) {
                    console.log('Calculating redispatched delays for all Accepted-Queued pairs...');
                    
                    // For each Accepted event, find the next Queued event that comes after it
                    for (let i = 0; i < acceptedEvents.length; i++) {
                        const acceptedEvent = acceptedEvents[i];
                        console.log(`Looking for Queued event after ${acceptedEvent.time} (${acceptedEvent.minutes} minutes)`);
                        
                        // Find the next Queued event after this Accepted event
                        for (let j = 0; j < queuedEvents.length; j++) {
                            const queuedEvent = queuedEvents[j];
                            
                            if (queuedEvent.minutes > acceptedEvent.minutes) {
                                let delay = queuedEvent.minutes - acceptedEvent.minutes;
                                if (delay < 0) delay += 1440;
                                
                                console.log(`Found delay: ${acceptedEvent.time} to ${queuedEvent.time} = ${delay} minutes`);
                                totalRedispatchedDelay += delay;
                                break; // Move to next Accepted event
                            }
                        }
                    }
                    
                    console.log(`Total redispatched delay: ${totalRedispatchedDelay} minutes`);
                }
                
                // Debug: Log the events found
                console.log('=== DEBUG INFO ===');
                console.log('Accepted events:', acceptedEvents);
                console.log('Queued events:', queuedEvents);
                console.log('Total delay:', totalRedispatchedDelay);
                console.log('Number of Accepted events:', acceptedEvents.length);
                console.log('Number of Queued events:', queuedEvents.length);
                
                // Debug: Log the main data to see what's being parsed
                console.log('Main data:', mainData);
                
                // Debug: Check each item individually
                for (const item of mainData) {
                    console.log('Event:', item.event, 'Time:', item.time, 'Contains accepted:', item.event.toLowerCase().includes('accepted'), 'Contains queued:', item.event.toLowerCase().includes('queued'), 'Contains manual undispatch:', item.event.toLowerCase().includes('manual undispatch'));
                }
                
                // Debug: Show the calculation process
                console.log('=== CALCULATION PROCESS ===');
                console.log('Using new logic for multiple Accepted events');
                console.log('Final total delay:', totalRedispatchedDelay);
                
                // If no queued events found, check the original input for Manual Undispatch
                if (queuedEvents.length === 0) {
                    console.log('No queued events found, checking original input...');
                    const originalInput = inputData.value;
                    const lines = originalInput.split('\n');
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        if (line.toLowerCase().includes('manual undispatch')) {
                            console.log('Found Manual Undispatch in line:', line);
                            // Extract time from the line
                            const timeMatch = line.match(/(\d{1,2}:\d{2}\s*[AP]M)/i);
                            if (timeMatch) {
                                queuedEvents.push({
                                    time: timeMatch[1],
                                    minutes: timeToMinutes(timeMatch[1]),
                                    event: 'Manual Undispatch'
                                });
                                console.log('Added Manual Undispatch event:', timeMatch[1]);
                            }
                        }
                    }
                }
                
                if (totalRedispatchedDelay > 0) {
                    delayRiderRedispatchedDiv.textContent = formatTimeDifference(totalRedispatchedDelay);
                    // Also update the "Order picked up/another rider" value
                    document.getElementById('order-picked-up-value').textContent = `(${formatTimeDifference(totalRedispatchedDelay)})`;
                    console.log(`Order picked up/another rider delay: ${totalRedispatchedDelay} minutes`);
                } else {
                    delayRiderRedispatchedDiv.textContent = 'Not available';
                    document.getElementById('order-picked-up-value').textContent = '(Not available)';
                }

                if (pickUpCommittedTime && pickUpUpdatedTime) {
                    const committedMinutes = timeToMinutes(pickUpCommittedTime);
                    const updatedMinutes = timeToMinutes(pickUpUpdatedTime);
                    let variance = updatedMinutes - committedMinutes;
                    if (variance < 0) variance += 1440;
                    pickUpdatedVarianceDiv.textContent = formatTimeDifference(variance);
                } else {
                    pickUpdatedVarianceDiv.textContent = 'Not available';
                }

                // Extract estimated dropoff departure time from main timeline data
                if (!estDropoffArrivalTime) {
                    // Look for the Accepted event which contains the estimated dropoff departure
                    for (const item of mainData) {
                        console.log('Checking item:', item.event, 'estDropoffDeparture:', item.estDropoffDeparture);
                        if (item.event.toLowerCase().includes('accepted') && item.estDropoffDeparture) {
                            estDropoffArrivalTime = item.estDropoffDeparture;
                            console.log('Found estimated dropoff departure from Accepted event:', estDropoffArrivalTime);
                            break;
                        }
                    }
                    
                    // If still not found, try to extract from the original input text
                    if (!estDropoffArrivalTime) {
                        console.log('Trying to extract from original input...');
                        const originalInput = inputData.value;
                        const lines = originalInput.split('\n');
                        
                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i];
                            if (line.toLowerCase().includes('accepted')) {
                                console.log('Found Accepted line:', line);
                                // Extract the last time in this line (should be the dropoff departure)
                                const timeMatches = line.match(/(\d{1,2}:\d{2}\s*[AP]M)/gi);
                                if (timeMatches && timeMatches.length > 0) {
                                    estDropoffArrivalTime = timeMatches[timeMatches.length - 1];
                                    console.log('Extracted dropoff departure from line:', estDropoffArrivalTime);
                                    break;
                                }
                            }
                        }
                    }
                }

                // Use manual input for estimated dropoff departure time
                const manualEstDropoff = estDropoffInput.value.trim();
                if (manualEstDropoff) {
                    const estDropoffMinutes = timeToMinutes(manualEstDropoff);
                    const parsedCurrentTime = parseCurrentTimeFormat(currentTime);
                    if (parsedCurrentTime) {
                        const currentMinutes = timeToMinutes(parsedCurrentTime);
                        let delayToDropoff = currentMinutes - estDropoffMinutes;
                        if (delayToDropoff < -720) delayToDropoff += 1440;
                        if (delayToDropoff > 720) delayToDropoff -= 1440;
                        delayToDropoff = Math.max(0, delayToDropoff);
                        
                        console.log('=== RIDER DELAY TO DROPOFF CALCULATION ===');
                        console.log('Manual estimated dropoff departure time:', manualEstDropoff);
                        console.log('Estimated dropoff minutes:', estDropoffMinutes);
                        console.log('Current time:', currentTime);
                        console.log('Parsed current time:', parsedCurrentTime);
                        console.log('Current minutes:', currentMinutes);
                        console.log('Raw delay calculation:', currentMinutes - estDropoffMinutes);
                        console.log('Final delay:', delayToDropoff);
                        
                        riderDelayDropoffDiv.textContent = formatTimeDifference(delayToDropoff);
                    } else {
                        riderDelayDropoffDiv.textContent = 'Invalid current time format';
                    }
                } else {
                    console.log('No manual estimated dropoff departure time entered');
                    riderDelayDropoffDiv.textContent = 'Not available';
                }

                let scheduledTime = null;
                let firstQueuedTimeForScheduled = null;
                for (const item of mainData) {
                    if (item.event.toLowerCase().includes('scheduled') && !scheduledTime) {
                        scheduledTime = item.time;
                    }
                    if (item.event.toLowerCase().includes('queue') && !firstQueuedTimeForScheduled) {
                        firstQueuedTimeForScheduled = item.time;
                    }
                }

                // Adjust scheduled time calculation based on order type
                if (selectedOrderType === 'nfv') {
                    if (scheduledTime && firstQueuedTimeForScheduled) {
                        const scheduledMinutes = timeToMinutes(scheduledTime);
                        const queuedMinutes = timeToMinutes(firstQueuedTimeForScheduled);
                        let timeDifference = queuedMinutes - scheduledMinutes;
                        if (timeDifference < 0) timeDifference += 1440;
                        scheduledTimeDiv.textContent = formatTimeDifference(timeDifference);
                    } else {
                        scheduledTimeDiv.textContent = 'Not available';
                    }
                } else if (selectedOrderType === 'normal') {
                    scheduledTimeDiv.textContent = formatTimeDifference(0);
                } else {
                    scheduledTimeDiv.textContent = '--';
                }

                // Store NFV delay for later use in preparation delay calculation
                if (selectedOrderType === 'nfv' && scheduledTime) {
                    const scheduledMinutes = timeToMinutes(scheduledTime);
                    let referenceMinutes = null;
                    
                    if (firstQueuedTimeForScheduled) {
                        // If there's a Queued event, use that as reference
                        referenceMinutes = timeToMinutes(firstQueuedTimeForScheduled);
                        nfvDelay = referenceMinutes - scheduledMinutes;
                        console.log(`NFV order: Scheduled to Queued delay calculated: ${nfvDelay} minutes`);
                    } else if (currentTime) {
                        // If no Queued event but we have current time, use current time as reference
                        const parsedCurrentTime = parseCurrentTimeFormat(currentTime);
                        if (parsedCurrentTime) {
                            referenceMinutes = timeToMinutes(parsedCurrentTime);
                            nfvDelay = referenceMinutes - scheduledMinutes;
                            console.log(`NFV order: Scheduled to Current time delay calculated: ${nfvDelay} minutes`);
                        }
                    } else if (pickUpCommittedTime) {
                        // If no current time, use Pickup - Committed as reference
                        referenceMinutes = timeToMinutes(pickUpCommittedTime);
                        nfvDelay = referenceMinutes - scheduledMinutes;
                        console.log(`NFV order: Scheduled to Pickup Committed delay calculated: ${nfvDelay} minutes`);
                    }
                    
                    if (nfvDelay < 0) nfvDelay += 1440;
                    if (nfvDelay > 0) {
                        console.log(`NFV order: Final preparation delay: ${nfvDelay} minutes`);
                    }
                }



                // Delay rider - redispatched calculation is already done above

                resultContainer.classList.add('visible');
            } else {
                resultContainer.classList.remove('visible');
            }

            if (additionalData.length > 0) {
                additionalData.forEach(item => {
                    const row = document.createElement('tr');
                    const eventCell = document.createElement('td');
                    eventCell.className = 'event';
                    eventCell.textContent = item.event;
                    const timeCell = document.createElement('td');
                    timeCell.className = 'timestamp';
                    timeCell.textContent = item.time;
                    row.appendChild(eventCell);
                    row.appendChild(timeCell);
                    additionalTimelineBody.appendChild(row);
                });
                additionalTimelineContainer.classList.add('visible');
            } else {
                additionalTimelineContainer.classList.remove('visible');
            }

            // Calculate Long Dispatching using the same logic as main dispatch time
            let longDispatchingSum = finalDispatchTime; // Use the corrected calculation
            document.getElementById('long-dispatching-value').textContent = `(${formatTimeDifference(longDispatchingSum)})`;

            // Rider is late to Pick Up (sum of Rider Delay and Delay rider - redispatched)
            // Get the text from the summary cards, parse to minutes
            function parseMinutesFromSummary(id) {
                const el = document.getElementById(id);
                if (!el) return 0;
                const text = el.textContent || '';
                const match = text.match(/(\d+)\s*hour[s]?\s*(\d+)?\s*minute[s]?|^(\d+)\s*minute[s]?/i);
                if (match) {
                    if (match[1]) {
                        // hours and minutes
                        return parseInt(match[1], 10) * 60 + (match[2] ? parseInt(match[2], 10) : 0);
                    } else if (match[3]) {
                        // only minutes
                        return parseInt(match[3], 10);
                    }
                }
                return 0;
            }
            let riderDelay = parseMinutesFromSummary('rider-delay');
            let riderLatePickupSum = riderDelay || 0;
            document.getElementById('rider-late-pickup-value').textContent = `(${formatTimeDifference(riderLatePickupSum)})`;

        

            // Rider is late to Drop Off (Rider Delay to Dropoff)
            let delayDropoff = parseMinutesFromSummary('rider-delay-dropoff');
            document.getElementById('late-dropoff-value').textContent = `(${formatTimeDifference(delayDropoff)})`;

            // Restaurant Waiting Time calculation (using pickup committed or near pickup based on rider arrival)
            let waitingTime = null;
            
            // Check if there's a Queued event after Near Pickup (indicating dispatch issue, not restaurant issue)
            let hasQueuedAfterNearPickup = false;
            if (firstNearPickupTime) {
                const nearPickupMinutes = timeToMinutes(firstNearPickupTime);
                for (const item of mainData) {
                    if (item.event.toLowerCase().includes('queue')) {
                        const queuedMinutes = timeToMinutes(item.time);
                        if (queuedMinutes > nearPickupMinutes) {
                            hasQueuedAfterNearPickup = true;
                            console.log(`Found Queued event after Near Pickup: ${item.time} (after ${firstNearPickupTime})`);
                    break;
                        }
                    }
                }
            }
            
            // Only calculate restaurant delay if there's no Queued event after Near Pickup
            if (!hasQueuedAfterNearPickup) {
            // Try to calculate using actual pickup time if available
            if (pickedUpAtTime) {
                const pickedUpMinutes = timeToMinutes(pickedUpAtTime);
                
                    if (pickUpCommittedTime && firstNearPickupTime) {
                    const committedMinutes = timeToMinutes(pickUpCommittedTime);
                        const nearPickupMinutes = timeToMinutes(firstNearPickupTime);
                        
                        if (nearPickupMinutes <= committedMinutes) {
                            // Case 1: Rider arrived BEFORE or AT committed time
                            waitingTime = pickedUpMinutes - committedMinutes;
                        } else {
                            // Case 2: Rider arrived AFTER committed time
                            waitingTime = pickedUpMinutes - nearPickupMinutes;
                        }
                    } else if (pickUpCommittedTime) {
                        // Fallback: only committed time available
                        const committedMinutes = timeToMinutes(pickUpCommittedTime);
                        waitingTime = pickedUpMinutes - committedMinutes;
                }
            }
            // If no actual pickup time, calculate preparation delay from current time
                else if (!pickedUpAtTime && currentTime && firstNearPickupTime) {
                const parsedCurrentTime = parseCurrentTimeFormat(currentTime);
                if (parsedCurrentTime) {
                    const currentMinutes = timeToMinutes(parsedCurrentTime);
                    
                        // Determine reference time based on rider arrival vs committed time
                    let referenceTime = null;
                        if (pickUpCommittedTime && firstNearPickupTime) {
                            const committedMinutes = timeToMinutes(pickUpCommittedTime);
                            const nearPickupMinutes = timeToMinutes(firstNearPickupTime);
                            
                            if (nearPickupMinutes <= committedMinutes) {
                                // Rider arrived BEFORE or AT committed time - use committed time
                                referenceTime = pickUpCommittedTime;
                            } else {
                                // Rider arrived AFTER committed time - use near pickup time
                                referenceTime = firstNearPickupTime;
                            }
                    } else if (pickUpCommittedTime) {
                        referenceTime = pickUpCommittedTime;
                    } else if (firstNearPickupTime) {
                        referenceTime = firstNearPickupTime;
                    }
                    
                    if (referenceTime) {
                        const referenceMinutes = timeToMinutes(referenceTime);
                        waitingTime = currentMinutes - referenceMinutes;
                        // Ensure positive value (preparation delay)
                        if (waitingTime < 0) waitingTime = 0;
                    }
                }
            }
            // If no actual pickup time and no current time, use the new comparison logic
            else if (!pickedUpAtTime && !currentTime && estPickupArrivalTime && pickUpCommittedTime && firstNearPickupTime) {
                const estPickupArrivalMinutes = timeToMinutes(estPickupArrivalTime);
                const committedMinutes = timeToMinutes(pickUpCommittedTime);
                const nearPickupMinutes = timeToMinutes(firstNearPickupTime);
                
                // Compare Estimated Pickup Arrival with Committed Pickup Time
                if (estPickupArrivalMinutes <= committedMinutes) {
                    // Estimated Pickup Arrival ≤ Committed Pickup Time
                    // Calculate delay from Pickup Committed Time to Near Pickup event
                    waitingTime = committedMinutes - nearPickupMinutes;
                } else {
                    // Estimated Pickup Arrival > Committed Pickup Time
                    // Calculate delay from Estimated Pickup Arrival to Near Pickup event
                    waitingTime = estPickupArrivalMinutes - nearPickupMinutes;
                }
                
                // Ensure positive value
                if (waitingTime < 0) waitingTime = 0;
            }
            // Fallback: try to estimate from timeline data if no current time
            else if (!waitingTime && pickUpCommittedTime && firstNearPickupTime) {
                const committedMinutes = timeToMinutes(pickUpCommittedTime);
                const nearPickupMinutes = timeToMinutes(firstNearPickupTime);   
                
                if (nearPickupMinutes < committedMinutes) {
                    // Use committed time as reference
                    waitingTime = committedMinutes - nearPickupMinutes;
                    }
                }
            } else {
                console.log(`Skipping restaurant delay calculation - found Queued event after Near Pickup`);
            }
            // Add NFV-specific delay (Scheduled to Queued time) to preparation delay
            console.log(`NFV delay check: nfvDelay = ${nfvDelay}, waitingTime = ${waitingTime}`);
            if (nfvDelay > 0) {
                if (waitingTime !== null && waitingTime >= 0) {
                    waitingTime += nfvDelay;
                    console.log(`NFV order: Added ${nfvDelay} minutes (Scheduled to Queued) to preparation delay. Total: ${waitingTime} minutes`);
                } else {
                    // For NFV orders, if no other preparation delay is calculated, use the NFV delay as the preparation delay
                    waitingTime = nfvDelay;
                    console.log(`NFV order: Set preparation delay to ${nfvDelay} minutes (Scheduled to Queued) - no other preparation delay available`);
                }
            }
            
            console.log(`Final waitingTime check: waitingTime = ${waitingTime}`);
            if (waitingTime !== null && waitingTime >= 0) {
                waitingTimeDiv.textContent = formatTimeDifference(waitingTime);
                document.getElementById('late-prep-value').textContent = `(${formatTimeDifference(waitingTime)})`;
                console.log('Preparation delay calculated:', waitingTime, 'minutes');
            } else {
                waitingTimeDiv.textContent = 'Not available';
                document.getElementById('late-prep-value').textContent = '(Not available)';
                console.log('Preparation delay not available');
            }

            let cancellationReason = '--';
            let unprofessionalOverride = false;

            // Helper to get minutes from delay reason fields
            function getDelayMinutes(id) {
                const el = document.getElementById(id);
                if (!el) {
                    console.log(`Element with id '${id}' not found`);
                    return 0;
                }
                const text = el.textContent || '';
                console.log(`Text content for ${id}: "${text}"`);
                const match = text.match(/\(?(\d+)\s*hour[s]?\s*(\d+)?\s*minute[s]?\)?|\(?(\d+)\s*minute[s]?\)?/i);
                if (match) {
                    if (match[1]) {
                        // hours and minutes
                        const result = parseInt(match[1], 10) * 60 + (match[2] ? parseInt(match[2], 10) : 0);
                        console.log(`Parsed ${id}: ${result} minutes (${match[1]}h ${match[2] || 0}m)`);
                        return result;
                    } else if (match[3]) {
                        // only minutes
                        const result = parseInt(match[3], 10);
                        console.log(`Parsed ${id}: ${result} minutes`);
                        return result;
                    }
                }
                console.log(`No match found for ${id}, returning 0`);
                return 0;
            }

            function showCancellationToast(reason) {
                const toast = document.getElementById('cancellation-toast');
                toast.textContent = reason;
                toast.style.display = 'block';
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(-50%) scale(0.95)';
                setTimeout(() => {
                    toast.style.opacity = '1';
                    toast.style.transform = 'translateX(-50%) scale(1.05)';
                }, 10);
                setTimeout(() => {
                    toast.style.opacity = '0';
                    toast.style.transform = 'translateX(-50%) scale(0.95)';
                    setTimeout(() => { toast.style.display = 'none'; }, 400);
                }, 50000);
            }
            function updateCancellationReason() {
                let cancellationReason = '--';
                if (unprofessionalOverride) {
                    cancellationReason = 'Unprofessional Behaviour';
                    showCancellationToast(cancellationReason);
                    return;
                }
                // Get all delay values
                const delays = [
                    { id: 'long-dispatching-value', label: 'Long Dispatching', reason: 'Lack of Delivery Men' },
                    { id: 'rider-late-pickup-value', label: 'Rider is late to Pick Up', reason: null },
                    { id: 'late-prep-value', label: 'Late preparation from the restaurant', reason: 'Preparation Delay' },
                    { id: 'late-dropoff-value', label: 'Rider is late to Drop Off', reason: null },
                    { id: 'order-picked-up-value', label: 'Order picked up/another rider', reason: 'Order picked up/delivered by another rider' }
                ];
                let maxDelay = 0;
                let maxDelayObj = null;
                for (const d of delays) {
                    const mins = getDelayMinutes(d.id);
                    console.log(`Delay ${d.label}:`, mins, 'minutes');
                    if (mins > maxDelay) {
                        maxDelay = mins;
                        maxDelayObj = { ...d, mins };
                    } else if (mins === maxDelay && d.label === 'Order picked up/another rider') {
                        // Prioritize "Order picked up/another rider" when it has the same value as other delays
                        maxDelayObj = { ...d, mins };
                        console.log(`Prioritizing ${d.label} over previous max delay`);
                    }
                }
                console.log('Maximum delay:', maxDelay, 'minutes, Reason:', maxDelayObj ? maxDelayObj.label : 'None');
                if (!maxDelayObj || maxDelay === 0) {
                    cancellationReason = '--';
                    showCancellationToast(cancellationReason);
                    return;
                }
                // Logic for each reason based on specifications
                if (maxDelayObj.label === 'Long Dispatching') {
                    // If the lateness due to Long Dispatching --> Lack of Delivery Men
                    cancellationReason = 'Lack of Delivery Men';
                } else if (maxDelayObj.label === 'Late preparation from the restaurant') {
                    // If the lateness due to Partner's Prep. --> Preparation Delay
                    cancellationReason = 'Preparation Delay';
                } else if (maxDelayObj.label === 'Rider is late to Pick Up' || maxDelayObj.label === 'Rider is late to Drop Off') {
                    console.log('Rider delay detected, selectedRiderStatus:', selectedRiderStatus);
                    if (selectedRiderStatus === 'unreachable') {
                        // If the rider is unreachable, we choose the reason (Rider unreachable)
                        cancellationReason = 'Rider Unreachable';
                    } else if (selectedRiderStatus === 'reachable') {
                        // If the lateness due to Rider in case the rider is reachable --> Late Delivery
                        cancellationReason = 'Late Delivery';
                    } else {
                        console.log('No rider status selected, defaulting to Late Delivery');
                        cancellationReason = 'Late Delivery';
                    }
                } else if (maxDelayObj.label === 'Order picked up/another rider') {
                    // If the lateness due to Order picked up/another rider --> Order picked up/delivered by another rider
                    cancellationReason = 'Order picked up/delivered by another rider';
                } else {
                    console.log('No matching delay type found, setting to --');
                    cancellationReason = '--';
                }
                console.log('Final cancellation reason:', cancellationReason);
                showCancellationToast(cancellationReason);
            }

            // Attach Unprofessional Behaviour button logic
            unprofessionalBtn.onclick = function() {
                unprofessionalOverride = true;
                updateCancellationReason();
            };

            updateCancellationReason();
        }

        // Add this helper function:
        function animateCancellationReason() {
            const card = document.getElementById('cancellation-reason-card');
            card.classList.remove('cancellation-pop');
            void card.offsetWidth; // trigger reflow
            card.classList.add('cancellation-pop');
            setTimeout(() => card.classList.remove('cancellation-pop'), 900);
        }
    });
</script>
<!-- tool 2 logic -->

<!-- tool 3 logic -->
<script>
    // Expanded keywords with abbreviations
    const keywords = [
        // Customer Flag
        {term: 'Red Flag', hint: 'High priority issue'},
        {term: 'Orange Flag', hint: 'Medium priority issue'},
        {term: 'Green Flag', hint: 'Low priority issue'},
        
        // Customer Type
        {term: 'Default customer', hint: ''},
        {term: 'TPRO CST', hint: 'TPRO Customer'},
        {term: 'VIP CST', hint: 'VIP Customer'},
        
        // Customer Inquiries
        {term: 'Complained about', hint: ''},
        {term: 'Late Delivery', hint: ''},
        {term: 'Wrong order', hint: ''},
        {term: 'Wrong item', hint: ''},
        {term: 'Missing item', hint: ''},
        {term: 'Expired', hint: ''},
        {term: 'Nearly Expired', hint: ''},
        {term: 'Foreign object', hint: ''},
        {term: 'Cooking instruction not followed', hint: ''},
        {term: 'Poor packaging', hint: ''},
        {term: 'Extra Amount Charged', hint: ''},
        {term: 'Money collection issue', hint: ''},
        {term: 'Order not delivered', hint: ''},
        {term: 'Order marked as delivered but didn\'t receive', hint: ''},
        {term: 'Order not assigned to a rider', hint: ''},
        
        // Contacts
        {term: 'RST', hint: 'Restaurant'}, 
        {term: 'CST', hint: 'Customer'},
        {term: 'CNA', hint: 'Customer Not Answering'},
        {term: 'ROP', hint: 'Restaurant Operator'},
        {term: 'Ven', hint: 'Vendor'},
        {term: 'Rider', hint: ''},
        {term: 'RNA', hint: 'Restaurant/Rider Not Answering'},
        {term: 'RM', hint: 'Rider Manager'},
        {term: 'AM', hint: 'Account Manager'},
        {term: 'MCB', hint: 'Manager Call Back'},
        {term: 'Left note on Hurrier', hint: ''},
        {term: 'Advice CST with Tracking Feature', hint: ''},
        
        // Status
        {term: 'Answered', hint: 'ANS'},
        {term: 'Not Answered', hint: ''},
        {term: 'FU', hint: 'Follow Up'},
        {term: 'WFA', hint: 'Waiting for Answer'},
        {term: 'BRB', hint: 'Be Right Back'},
        {term: 'Not Eligible for PR', hint: 'Not Eligible for Partial Refund'},
        
        // Time/Delivery
        {term: 'WDT', hint: 'Within Delivery Time'},
        {term: 'PDT', hint: 'Promise Delivery Time'},
        {term: 'DT', hint: 'Delivery Time'},
        {term: 'ETA', hint: 'Estimated Time Arrival'},
        {term: 'ETA from to', hint: 'ETA from XX to XX'},
        {term: 'OTW', hint: 'On The Way'},
        {term: 'ASAP', hint: 'As Soon As Possible'},
        {term: 'Under Prep', hint: 'Under Preparation'},
        {term: 'Min', hint: 'Minute(s)'},
        {term: 'Mins', hint: 'Minutes'},
        {term: 'H', hint: 'Hour(s)'},
        {term: 'Hrs', hint: 'Hours'},
        {term: 'End Time +10 minutes', hint: ''},
        {term: 'Order more than 50% from the delivery time', hint: ''},
        
        // Actions
        {term: 'Info', hint: 'Informed'},
        {term: 'TC', hint: 'Talabat Credit'},
        {term: 'R&V', hint: 'Refund & Validation'},
        {term: 'Comp', hint: 'Compensation'},
        {term: 'OT', hint: 'Offline Ticket'},
        {term: 'SLA', hint: 'Service Level Agreement'},
        {term: 'PR', hint: 'Partial Refund'},
        {term: 'FR', hint: 'Full Refund'},
        {term: 'App', hint: 'Application'},
        {term: 'Fill FORM', hint: ''},
        {term: 'Advice CST to wait', hint: ''},
        {term: 'Advice CST to place a new order', hint: ''},
        
        // Compensation
        {term: 'Can not comp', hint: 'Cannot compensate'},
        {term: 'Fraud detected', hint: ''},
        {term: 'Budget limit', hint: ''},
        {term: 'Apply Comp', hint: 'Apply Compensation'},
        {term: 'Comp before', hint: 'Compensated before'},
        {term: 'Comp 0 amount', hint: 'Compensation 0 amount'},
        {term: 'Exceeded 3 times capping', hint: ''},
        {term: 'CST eligible for partial refund', hint: ''},
        {term: 'Less than threshold', hint: ''},
        {term: 'More than threshold', hint: ''},
        
        // Documentation
        {term: 'PIC', hint: 'Picture'},
        {term: 'SS', hint: 'Screenshot'},
        {term: 'T&C', hint: 'Terms & Conditions'},
        {term: 'Msg', hint: 'Message'},
        {term: 'SMS', hint: 'Short Message Service'},
        {term: 'Num', hint: 'Number'},
        {term: 'Acc', hint: 'Account'},
        {term: 'No PIN Code', hint: ''},
        {term: 'No Dispatche notes', hint: ''},
        {term: 'CST share correct address', hint: ''},
        {term: 'Rider not moving', hint: ''},
        {term: 'Completed for less than 20 min', hint: ''},
        {term: 'Completed for more than 20 min', hint: ''},
        {term: 'CST insist to cancel', hint: ''},
        {term: 'CST good history', hint: ''},
        {term: 'Package was sealed', hint: ''},
        
        // Personnel/Other
        {term: 'SPV', hint: 'Supervisor'},
        {term: 'TL', hint: 'Team Leader'},
        {term: 'SME', hint: 'Subject Matter Expert'},
        {term: 'VP', hint: 'Vendor Portal'},
        {term: 'Dr', hint: 'Doctor'},
        {term: 'HC', hint: 'Hero Care'},
        {term: 'T2', hint: 'Tier 2'},
        {term: 'T3', hint: 'Tier 3'},
        {term: 'BOA', hint: 'Backoffice'},
        {term: 'CBH', hint: 'Customer Bad History'},
        {term: 'CGH', hint: 'Customer Good History'},
        {term: 'BL', hint: 'Backlog'},
        {term: 'Rider status (Accepted)', hint: ''},
        {term: 'Rider status (Near pickup)', hint: ''},
        {term: 'Rider status (Left pickup/Pickedup)', hint: ''},
        {term: 'Rider status (Neardrop off)', hint: ''},
        {term: 'Hurrier status', hint: ''},
        {term: 'Order ready waiting for Rider', hint: ''},
        {term: 'Rider said at RST waiting order', hint: ''},
        {term: 'Rider said correct address', hint: ''},
        {term: 'Rider said wrong address', hint: ''},
        {term: 'Asked him hurry up and call CST', hint: ''}
    ];

    // Smart Shortcuts
    const smartShortcuts = {
        '!refund': 'Processed partial refund of [amount] as per policy. Customer notified via SMS.',
        '!delivery': 'Order delayed by [time]. Contacted rider (RNA). Updated customer with new ETA: [time].',
        '!complaint': 'Customer complained about [issue]. Apologized and offered [solution]. Case marked as [status].',
        '!tc': 'Issued Talabat Credit of [amount] as compensation. Customer informed.',
        '!followup': 'Case requires follow-up. Scheduled callback for [date/time].',
        '!escalate': 'Escalated to [TL/SPV] for further investigation. Case marked as high priority.',
        '!lateorder': 'CST complain about late order. Rider status: [status]. Informed CST with End Time +10 minutes. CST info.',
        '!notdelivered': 'Order marked as delivered but CST didn\'t receive. No PIN Code. Rider not moving (RNA). Advice CST to wait. CST info.',
        '!missingitem': 'CST complain about missing item [item]. Item amount [amount]. CST said package was sealed. [Less/More] than threshold. [Action taken]. CST info.'
    };

    // Common misspellings and grammar issues
    const commonMisspellings = [
        'recieve', 'seperate', 'definately', 'occured', 'untill', 'wich', 
        'accomodate', 'wich', 'alot', 'becuase', 'comming', 'existance',
        'harrass', 'occassion', 'persue', 'refered', 'suprise', 'thier'
    ];

    const grammarIssues = [
        { pattern: /\bI\s+promise\b/gi, suggestion: 'I will do my best' },
        { pattern: /\bguarantee\b/gi, suggestion: 'assure' },
        { pattern: /\bnever\b.*\bhappen\b/gi, suggestion: 'will do our best to prevent' },
        { pattern: /\balways\b/gi, suggestion: 'often' },
        { pattern: /\bperfect\b/gi, suggestion: 'good' }
    ];

    // Templates
    let savedTemplates = [
        { name: 'Complaint', content: 'Customer complained about [issue]. Apologized and offered [solution]. Case marked as [status].' },
        { name: 'Refund', content: 'Processed [partial/full] refund of [amount] due to [reason]. Customer [satisfied/not satisfied].' },
        { name: 'Delivery', content: 'Order #12345 delayed by [time]. Contacted rider (RNA). Updated customer with new ETA: [time].' },
        { name: 'Late Order', content: 'CST complain about late order. Rider status: [status]. Informed CST with End Time +10 minutes. CST info.' },
        { name: 'Not Delivered', content: 'Order marked as delivered but CST didn\'t receive. No PIN Code. Rider not moving (RNA). Advice CST to wait. CST info.' },
        { name: 'Missing Item', content: 'CST complain about missing item [item]. Item amount [amount]. CST said package was sealed. [Less/More] than threshold. [Action taken]. CST info.' }
    ];

    // History
    let historyItems = [];
    const MAX_HISTORY_ITEMS = 10;

    // Custom quick actions
    let customQuickActions = [];

    // Page elements
    const documentationInput = document.getElementById('documentationInput');
    const autocompleteList = document.getElementById('autocompleteList');
    const previewSection = document.getElementById('previewSection');
    const previewContent = document.getElementById('previewContent');
    const generateBtn = document.getElementById('generateBtn');
    const copyBtn = document.getElementById('copyBtn');
    const saveTemplateBtn = document.getElementById('saveTemplateBtn');
    const resetBtn = document.getElementById('resetBtn');
    const templatesList = document.getElementById('templatesList');
    const historyList = document.getElementById('historyList');
    const historySearch = document.getElementById('historySearch');
    const quickActions = document.getElementById('quickActions');
    const quickActionsSearch = document.getElementById('quickActionsSearch');
    const addQuickActionBtn = document.getElementById('addQuickActionBtn');
    const sidebarHandle = document.getElementById('sidebarHandle');
    
    // Modal elements
    const quickActionModal = document.getElementById('quickActionModal');
    const closeModal = document.querySelector('.close-modal');
    const cancelQuickActionBtn = document.getElementById('cancelQuickActionBtn');
    const saveQuickActionBtn = document.getElementById('saveQuickActionBtn');
    const quickActionText = document.getElementById('quickActionText');
    const quickActionTooltip = document.getElementById('quickActionTooltip');
    const quickActionSection = document.getElementById('quickActionSection');
    const quickActionColor = document.getElementById('quickActionColor');

    let currentTextarea = documentationInput;
    let currentSuggestions = [];
    let selectedSuggestionIndex = -1;
    let lastSpaceTime = 0;
    let draggedSection = null;
    let draggedSectionIndex = -1;
    let draggedAction = null;
    let sidebarHideTimeout;

    // Initialize the app
    function init() {
        loadTemplates();
        loadHistory();
        loadSectionOrder();
        loadCustomQuickActions();
        setupEventListeners();
        setupDragAndDrop();
        setupActionDragAndDrop();
        setupSidebarHover();
    }

    // Setup sidebar hover functionality
    function setupSidebarHover() {
        // Show sidebar when hovering over handle
        sidebarHandle.addEventListener('mouseenter', () => {
            clearTimeout(sidebarHideTimeout);
            quickActions.classList.add('visible');
        });
        
        // Hide sidebar when mouse leaves sidebar
        quickActions.addEventListener('mouseleave', () => {
            sidebarHideTimeout = setTimeout(() => {
                quickActions.classList.remove('visible');
            }, 500);
        });
        
        // Prevent hiding when mouse is over sidebar
        quickActions.addEventListener('mouseenter', () => {
            clearTimeout(sidebarHideTimeout);
        });
        
        // Also show sidebar when mouse approaches right edge
        document.addEventListener('mousemove', (e) => {
            if (e.clientX >= window.innerWidth - 20) {
                clearTimeout(sidebarHideTimeout);
                quickActions.classList.add('visible');
            }
        });
    }

    // Load templates from localStorage
    function loadTemplates() {
        const storedTemplates = localStorage.getItem('savedTemplates');
        if (storedTemplates) {
            savedTemplates = JSON.parse(storedTemplates);
            renderTemplates();
        }
    }

    // Load history from localStorage
    function loadHistory() {
        const storedHistory = localStorage.getItem('documentationHistory');
        if (storedHistory) {
            historyItems = JSON.parse(storedHistory);
            renderHistory();
        }
    }

    // Load section order from localStorage
    function loadSectionOrder() {
        const storedOrder = localStorage.getItem('sectionOrder');
        if (storedOrder) {
            const order = JSON.parse(storedOrder);
            const sections = Array.from(quickActions.querySelectorAll('.section-group'));
            
            // Reorder sections based on saved order
            order.forEach((sectionTitle, index) => {
                const section = sections.find(s => s.getAttribute('data-section') === sectionTitle);
                if (section) {
                    quickActions.appendChild(section);
                }
            });
        }
    }

    // Load custom quick actions from localStorage
    function loadCustomQuickActions() {
        const storedActions = localStorage.getItem('customQuickActions');
        if (storedActions) {
            customQuickActions = JSON.parse(storedActions);
            renderCustomQuickActions();
        }
    }

    // Save templates to localStorage
    function saveTemplates() {
        localStorage.setItem('savedTemplates', JSON.stringify(savedTemplates));
    }

    // Save history to localStorage
    function saveHistory() {
        localStorage.setItem('documentationHistory', JSON.stringify(historyItems));
    }

    // Save section order to localStorage
    function saveSectionOrder() {
        const sections = Array.from(quickActions.querySelectorAll('.section-group'));
        const order = sections.map(section => {
            return section.getAttribute('data-section');
        });
        localStorage.setItem('sectionOrder', JSON.stringify(order));
    }

    // Save custom quick actions to localStorage
    function saveCustomQuickActions() {
        localStorage.setItem('customQuickActions', JSON.stringify(customQuickActions));
    }

    // Render templates
    function renderTemplates() {
        templatesList.innerHTML = '';
        savedTemplates.forEach(template => {
            const div = document.createElement('div');
            div.className = 'template-item';
            div.innerHTML = `
                ${template.name}: ${template.content.substring(0, 50)}${template.content.length > 50 ? '...' : ''}
                <button class="delete-template" title="Delete template">×</button>
            `;
            div.setAttribute('data-content', template.content);
            div.addEventListener('click', (e) => {
                if (!e.target.classList.contains('delete-template')) {
                    documentationInput.value = template.content;
                    documentationInput.focus();
                }
            });
            
            const deleteBtn = div.querySelector('.delete-template');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm('Are you sure you want to delete this template?')) {
                    savedTemplates = savedTemplates.filter(t => t.name !== template.name);
                    saveTemplates();
                    renderTemplates();
                }
            });
            
            templatesList.appendChild(div);
        });
    }

    // Render history
    function renderHistory() {
        historyList.innerHTML = '';
        const searchTerm = historySearch.value.toLowerCase();
        
        historyItems
            .filter(item => item.toLowerCase().includes(searchTerm))
            .forEach(item => {
                const div = document.createElement('div');
                div.className = 'history-item';
                div.textContent = item.substring(0, 80) + (item.length > 80 ? '...' : '');
                div.setAttribute('data-content', item);
                div.addEventListener('click', () => {
                    documentationInput.value = item;
                    documentationInput.focus();
                });
                historyList.appendChild(div);
            });
    }

    // Render custom quick actions
    function renderCustomQuickActions() {
        customQuickActions.forEach(action => {
            const section = quickActions.querySelector(`.section-group[data-section="${action.section}"]`);
            if (section) {
                const actionButtons = section.querySelector('.action-buttons');
                if (actionButtons) {
                    const button = createActionButton(action);
                    actionButtons.appendChild(button);
                }
            }
        });
    }

    // Create an action button
    function createActionButton(action) {
        const button = document.createElement('button');
        button.className = 'action-btn';
        if (action.color) {
            button.classList.add(action.color);
        }
        button.textContent = action.text;
        button.setAttribute('data-text', action.text);
        if (action.tooltip) {
            button.setAttribute('data-tooltip', action.tooltip);
        }
        button.setAttribute('draggable', 'true');
        button.setAttribute('data-custom', 'true');
        
        // Add drag events
        button.addEventListener('dragstart', handleActionDragStart);
        button.addEventListener('dragend', handleActionDragEnd);
        
        // Add click event to insert text
        button.addEventListener('click', () => {
            if (currentTextarea) {
                const textToAdd = button.getAttribute('data-text');
                const startPos = currentTextarea.selectionStart;
                const endPos = currentTextarea.selectionEnd;
                const text = currentTextarea.value;
                
                currentTextarea.value = text.substring(0, startPos) + textToAdd + ' ' + text.substring(endPos);
                currentTextarea.focus();
                currentTextarea.selectionStart = currentTextarea.selectionEnd = startPos + textToAdd.length + 1;
            }
        });
        
        return button;
    }

    // Add to history
    function addToHistory(text) {
        if (!text.trim()) return;
        
        // Remove duplicates
        historyItems = historyItems.filter(item => item !== text);
        
        // Add to beginning
        historyItems.unshift(text);
        
        // Limit history size
        if (historyItems.length > MAX_HISTORY_ITEMS) {
            historyItems.pop();
        }
        
        saveHistory();
        renderHistory();
    }

    // Setup event listeners
    function setupEventListeners() {
        // Documentation input
        documentationInput.addEventListener('input', handleInput);
        documentationInput.addEventListener('focus', () => currentTextarea = documentationInput);
        documentationInput.addEventListener('keydown', handleKeyDown);
        
        // Smart Shortcuts detection
        documentationInput.addEventListener('keyup', checkForShortcuts);
        
        // Generate preview button
        generateBtn.addEventListener('click', generatePreview);
        
        // Copy button
        copyBtn.addEventListener('click', copyToClipboard);
        
        // Save as template button
        saveTemplateBtn.addEventListener('click', saveAsTemplate);
        
        // Reset button
        resetBtn.addEventListener('click', resetDocumentation);
        
        // History search
        historySearch.addEventListener('input', renderHistory);
        
        // Quick actions search
        quickActionsSearch.addEventListener('input', filterQuickActions);
        
        // Add quick action button
        addQuickActionBtn.addEventListener('click', () => {
            quickActionModal.style.display = 'block';
        });
        
        // Modal close button
        closeModal.addEventListener('click', () => {
            quickActionModal.style.display = 'none';
        });
        
        // Modal cancel button
        cancelQuickActionBtn.addEventListener('click', () => {
            quickActionModal.style.display = 'none';
        });
        
        // Modal save button
        saveQuickActionBtn.addEventListener('click', saveQuickAction);
        
        // Close modal when clicking outside
        window.addEventListener('click', (e) => {
            if (e.target === quickActionModal) {
                quickActionModal.style.display = 'none';
            }
        });
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (!autocompleteList.contains(e.target) && e.target !== documentationInput) {
                hideAutocomplete();
            }
        });
    }

    // Setup drag and drop for sections
    function setupDragAndDrop() {
        const sections = quickActions.querySelectorAll('.section-title');
        
        sections.forEach(section => {
            section.addEventListener('dragstart', (e) => {
                draggedSection = section.parentElement; // Get the section-group
                draggedSectionIndex = Array.from(quickActions.querySelectorAll('.section-group')).indexOf(draggedSection);
                e.dataTransfer.setData('text/plain', section.textContent);
                section.classList.add('dragging');
                setTimeout(() => {
                    draggedSection.style.display = 'none';
                }, 0);
            });
            
            section.addEventListener('dragend', () => {
                if (draggedSection) {
                    draggedSection.style.display = 'block';
                    const sectionTitle = draggedSection.querySelector('.section-title');
                    if (sectionTitle) {
                        sectionTitle.classList.remove('dragging');
                    }
                }
                draggedSection = null;
                draggedSectionIndex = -1;
            });
        });
        
        quickActions.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (!draggedSection) return;
            
            const afterElement = getDragAfterElement(quickActions, e.clientY);
            const placeholder = document.querySelector('.drag-placeholder');
            
            if (!placeholder) {
                const placeholder = document.createElement('div');
                placeholder.classList.add('drag-placeholder');
                quickActions.appendChild(placeholder);
            }
            
            if (afterElement) {
                quickActions.insertBefore(placeholder, afterElement);
            } else {
                quickActions.appendChild(placeholder);
            }
        });
        
        quickActions.addEventListener('drop', (e) => {
            e.preventDefault();
            const placeholder = document.querySelector('.drag-placeholder');
            if (placeholder && draggedSection) {
                quickActions.insertBefore(draggedSection, placeholder);
                quickActions.removeChild(placeholder);
                
                saveSectionOrder();
            }
        });
        
        quickActions.addEventListener('dragleave', () => {
            const placeholder = document.querySelector('.drag-placeholder');
            if (placeholder) {
                quickActions.removeChild(placeholder);
            }
        });
    }

    // Setup drag and drop for action buttons
    function setupActionDragAndDrop() {
        const actionButtons = quickActions.querySelectorAll('.action-btn[draggable="true"]');
        
        actionButtons.forEach(button => {
            button.addEventListener('dragstart', handleActionDragStart);
            button.addEventListener('dragend', handleActionDragEnd);
        });
        
        // Set up drop zones (action-buttons containers)
        const actionContainers = quickActions.querySelectorAll('.action-buttons');
        actionContainers.forEach(container => {
            container.addEventListener('dragover', handleActionDragOver);
            container.addEventListener('dragleave', handleActionDragLeave);
            container.addEventListener('drop', handleActionDrop);
        });
    }

    // Handle action drag start
    function handleActionDragStart(e) {
        draggedAction = e.target;
        e.dataTransfer.setData('text/plain', e.target.textContent);
        e.target.classList.add('dragging');
        setTimeout(() => {
            e.target.style.opacity = '0.4';
        }, 0);
    }

    // Handle action drag end
    function handleActionDragEnd(e) {
        e.target.classList.remove('dragging');
        e.target.style.opacity = '1';
        draggedAction = null;
        
        // Remove drag-over class from all containers
        const containers = quickActions.querySelectorAll('.action-buttons');
        containers.forEach(container => {
            container.classList.remove('drag-over');
        });
    }

    // Handle action drag over
    function handleActionDragOver(e) {
        e.preventDefault();
        e.currentTarget.classList.add('drag-over');
    }

    // Handle action drag leave
    function handleActionDragLeave(e) {
        e.currentTarget.classList.remove('drag-over');
    }

    // Handle action drop
    function handleActionDrop(e) {
        e.preventDefault();
        e.currentTarget.classList.remove('drag-over');
        
        if (draggedAction) {
            // Check if we're moving within the same container
            if (e.currentTarget !== draggedAction.parentElement) {
                // Move to new container
                e.currentTarget.appendChild(draggedAction);
                
                // Update custom action data if this is a custom action
                if (draggedAction.getAttribute('data-custom') === 'true') {
                    const section = e.currentTarget.parentElement.getAttribute('data-section');
                    const text = draggedAction.getAttribute('data-text');
                    
                    // Find and update the action
                    const actionIndex = customQuickActions.findIndex(a => a.text === text);
                    if (actionIndex !== -1) {
                        customQuickActions[actionIndex].section = section;
                        saveCustomQuickActions();
                    }
                }
            }
        }
    }

    // Helper function for drag and drop
    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.section-group:not(.dragging)')];
        
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Filter quick actions based on search term
    function filterQuickActions() {
        const searchTerm = quickActionsSearch.value.toLowerCase();
        const sections = quickActions.querySelectorAll('.section-group');
        
        sections.forEach(section => {
            const sectionTitle = section.querySelector('.section-title').textContent.toLowerCase();
            const actionButtons = section.querySelectorAll('.action-btn');
            let hasVisibleActions = false;
            
            actionButtons.forEach(button => {
                const buttonText = button.textContent.toLowerCase();
                if (buttonText.includes(searchTerm) || sectionTitle.includes(searchTerm)) {
                    button.style.display = 'inline-block';
                    hasVisibleActions = true;
                } else {
                    button.style.display = 'none';
                }
            });
            
            // Show/hide entire section based on visibility of actions
            if (hasVisibleActions || searchTerm === '') {
                section.style.display = 'block';
            } else {
                section.style.display = 'none';
            }
        });
    }

    // Save new quick action
    function saveQuickAction() {
        const text = quickActionText.value.trim();
        const tooltip = quickActionTooltip.value.trim();
        const section = quickActionSection.value;
        const color = quickActionColor.value;
        
        if (!text) {
            alert('Please enter action text');
            return;
        }
        
        const newAction = {
            text,
            tooltip,
            section,
            color
        };
        
        customQuickActions.push(newAction);
        saveCustomQuickActions();
        
        // Add to UI
        const sectionElement = quickActions.querySelector(`.section-group[data-section="${section}"]`);
        if (sectionElement) {
            const actionButtons = sectionElement.querySelector('.action-buttons');
            if (actionButtons) {
                const button = createActionButton(newAction);
                actionButtons.appendChild(button);
            }
        }
        
        // Reset form and close modal
        quickActionText.value = '';
        quickActionTooltip.value = '';
        quickActionColor.value = '';
        quickActionModal.style.display = 'none';
    }

    // Check for smart shortcuts
    function checkForShortcuts(e) {
        if (e.key === ' ') {
            const text = documentationInput.value;
            const lastWord = text.split(/\s+/).pop();
            
            if (lastWord in smartShortcuts) {
                const startPos = documentationInput.selectionStart;
                const endPos = documentationInput.selectionEnd;
                const wordStart = text.lastIndexOf(lastWord);
                
                documentationInput.value = 
                    text.substring(0, wordStart) + 
                    smartShortcuts[lastWord] + 
                    text.substring(endPos);
                
                documentationInput.selectionStart = documentationInput.selectionEnd = 
                    wordStart + smartShortcuts[lastWord].length;
            }
        }
    }

    // Handle input to show suggestions
    function handleInput(e) {
        const value = e.target.value;
        const cursorPos = e.target.selectionStart;
        const textBeforeCursor = value.substring(0, cursorPos);
        const lastWord = textBeforeCursor.split(/[\s,]+/).pop();
        
        if (lastWord.length > 0) {
            currentSuggestions = keywords.filter(item => 
                item.term.toLowerCase().startsWith(lastWord.toLowerCase())
            );
            
            if (currentSuggestions.length > 0) {
                showAutocomplete(currentSuggestions, e.target, cursorPos, lastWord.length);
            } else {
                hideAutocomplete();
            }
        } else {
            hideAutocomplete();
        }
    }

    // Handle key events
    function handleKeyDown(e) {
        // Tab key for autocomplete
        if (e.key === 'Tab' && autocompleteList.style.display === 'block') {
            e.preventDefault();
            if (selectedSuggestionIndex >= 0 && currentSuggestions[selectedSuggestionIndex]) {
                insertSuggestion(currentSuggestions[selectedSuggestionIndex].term);
            } else if (currentSuggestions.length > 0) {
                insertSuggestion(currentSuggestions[0].term);
            }
        }
        // Arrow keys for navigation
        else if (e.key === 'ArrowDown' && autocompleteList.style.display === 'block') {
            e.preventDefault();
            navigateSuggestions(1);
        }
        else if (e.key === 'ArrowUp' && autocompleteList.style.display === 'block') {
            e.preventDefault();
            navigateSuggestions(-1);
        }
        // Double space for //
        else if (e.key === ' ') {
            const now = Date.now();
            if (now - lastSpaceTime < 300) { // 300ms threshold for double space
                e.preventDefault();
                const start = currentTextarea.selectionStart;
                const end = currentTextarea.selectionEnd;
                currentTextarea.value = currentTextarea.value.substring(0, start - 1) + '// ' + currentTextarea.value.substring(end);
                currentTextarea.selectionStart = currentTextarea.selectionEnd = start + 2;
            }
            lastSpaceTime = now;
        }
    }

    // Navigate through suggestions
    function navigateSuggestions(direction) {
        const suggestions = document.querySelectorAll('.autocomplete-suggestion');
        if (suggestions.length === 0) return;

        // Remove previous selection
        if (selectedSuggestionIndex >= 0) {
            suggestions[selectedSuggestionIndex].classList.remove('selected');
        }

        // Calculate new index
        selectedSuggestionIndex += direction;
        if (selectedSuggestionIndex < 0) selectedSuggestionIndex = suggestions.length - 1;
        if (selectedSuggestionIndex >= suggestions.length) selectedSuggestionIndex = 0;

        // Apply new selection
        suggestions[selectedSuggestionIndex].classList.add('selected');
        suggestions[selectedSuggestionIndex].scrollIntoView({
            block: 'nearest'
        });
    }

    // Insert suggestion at cursor position
    function insertSuggestion(term) {
        const value = currentTextarea.value;
        const cursorPos = currentTextarea.selectionStart;
        const textBeforeCursor = value.substring(0, cursorPos);
        const lastWord = textBeforeCursor.split(/[\s,]+/).pop();
        const wordStartPos = cursorPos - lastWord.length;
        
        currentTextarea.value = value.substring(0, wordStartPos) + term + ' ' + value.substring(cursorPos);
        currentTextarea.focus();
        currentTextarea.selectionStart = currentTextarea.selectionEnd = wordStartPos + term.length + 1;
        hideAutocomplete();
    }

    // Show autocomplete list with hints
    function showAutocomplete(suggestions, textarea, cursorPos, wordLength) {
        autocompleteList.innerHTML = '';
        selectedSuggestionIndex = -1;
        
        suggestions.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = 'autocomplete-suggestion';
            
            // Highlight matching part
            const matchingPart = item.term.substring(0, wordLength);
            const remainingPart = item.term.substring(wordLength);
            
            div.innerHTML = `<b>${matchingPart}</b>${remainingPart}` + 
                           (item.hint ? `<div class="keyword-hint">${item.hint}</div>` : '');
            
            div.addEventListener('click', () => {
                insertSuggestion(item.term);
            });
            autocompleteList.appendChild(div);
        });
        
        const rect = textarea.getBoundingClientRect();
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
        autocompleteList.style.display = 'block';
        autocompleteList.style.top = (rect.top + rect.height + scrollTop) + 'px';
        autocompleteList.style.left = rect.left + 'px';
    }

    // Hide autocomplete list
    function hideAutocomplete() {
        autocompleteList.style.display = 'none';
        selectedSuggestionIndex = -1;
        currentSuggestions = [];
    }

    // Add text when buttons are clicked
    document.querySelectorAll('.action-btn').forEach(btn => {
        if (!['copyBtn', 'generateBtn', 'saveTemplateBtn', 'resetBtn'].includes(btn.id)) {
            btn.addEventListener('click', () => {
                if (currentTextarea) {
                    const textToAdd = btn.getAttribute('data-text');
                    const startPos = currentTextarea.selectionStart;
                    const endPos = currentTextarea.selectionEnd;
                    const text = currentTextarea.value;
                    
                    currentTextarea.value = text.substring(0, startPos) + textToAdd + ' ' + text.substring(endPos);
                    currentTextarea.focus();
                    currentTextarea.selectionStart = currentTextarea.selectionEnd = startPos + textToAdd.length + 1;
                }
            });
        }
    });

    // Generate preview with spelling and grammar check
    function generatePreview() {
        const text = documentationInput.value;
        
        // Add to history
        addToHistory(text);
        
        // Check for spelling errors
        let previewText = text;
        
        // Check spelling
        commonMisspellings.forEach(misspelling => {
            const regex = new RegExp(`\\b${misspelling}\\b`, 'gi');
            if (regex.test(text)) {
                previewText = previewText.replace(regex, match => 
                    `<span class="spelling-error" title="Possible spelling error: ${misspelling}">${match}</span>`
                );
            }
        });
        
        // Check grammar
        grammarIssues.forEach(issue => {
            if (issue.pattern.test(text)) {
                previewText = previewText.replace(issue.pattern, match => 
                    `<span class="grammar-error" title="Suggested: ${issue.suggestion}">${match}</span>`
                );
            }
        });
        
        previewContent.innerHTML = previewText;
        previewSection.style.display = 'block';
    }

    // Copy to clipboard
    function copyToClipboard() {
        const fullComment = documentationInput.value;
        
        navigator.clipboard.writeText(fullComment).then(() => {
            alert('Comment copied to clipboard!');
            addToHistory(fullComment);
        });
    }

    // Save as template
    function saveAsTemplate() {
        const content = documentationInput.value.trim();
        if (!content) {
            alert('Please enter some text before saving as template.');
            return;
        }
        
        const name = prompt('Enter a name for this template:');
        if (name) {
            savedTemplates.push({ name, content });
            saveTemplates();
            renderTemplates();
        }
    }

    // Reset documentation
    function resetDocumentation() {
        if (confirm('Are you sure you want to reset the documentation field?')) {
            documentationInput.value = '';
            previewSection.style.display = 'none';
            documentationInput.focus();
        }
    }

    // Initialize the app
    init();
</script>
<!-- tool 3 logic -->

</body>
</html>
